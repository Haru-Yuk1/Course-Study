# 算法课程总结

## 一、异或运算可以理解为无进位相加

eg: a=10110 b=00111 a^b=10001

性质：

(1)a^0=a a^a=0

(2)满足交换律和结合律

(3)跟异或顺序无关，(2)推出的





==异或运算可以用来实现两个数之间交换==：

![image-20230919192808241](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20230919192808241-17015066230472.png)

注意：a,b值可以一样，但==指向的地址==必须不一样，在数组中，a[i]和a[j] i和j一定不能一样，不然会变成0

eg：

<font size=4>**给一个整型数组，（1）其中一种数出现的次数为奇数次，其他数出现次数为偶数次，找到这个数（2）其中两种数出现次数为奇数次，其他数出现次数为偶数次，找到这个数**</font>

**(1)准备一个变量 int eor=0，让他遍历异或，最后得到的eor便是该数。**

![image-20230919193900214](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20230919193900214.png)





```python
#一种数出现次数位奇数次，其他数出现次数位偶数次的数组，找到这个数
def printOddTimesNum1(arr):
    eor=0
    for i in arr:
        eor^=i
    print(eor)
```

**(2)第一步遍历异或一遍，可得到eor=a^b,肯定eor!=0,则可找到一个位置为1，然后再遍历一遍找这个位置是一的奇数次的数即可**

![image-20230919200127980](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20230919200127980.png)

```python
#其中两种数出现次数位奇数次，其他数出现次数为偶数次，找到这两个数
def printOddTimesNum2(arr):
    eor=0
    for i in arr:
        eor^=i
    rightone=eor&(~eor+1) #提取出最右的1，比如eor=1010111100 则~eor=01010000100,~eor+1=01010001,eor&(~eor+1)=0000000100
    onlyone=0
    for i in arr:
        if i&rightone==0:
            onlyone^=i
    print(f'{onlyone}和{onlyone^eor}')

```

思考：如果奇数次3种，4种呢，如果偶数次1次，2次呢？

答：偶数可以用同或，奇数次多种暂时没想出来

## 二、各种排序算法

### 基于比较的排序

### 1.选择排序——时间复杂度：$O(N^2)$、空间复杂度：$O(1)$

> 遍历数组找到最小值并放到开头，接着再找下一个。
>
> ![在这里插入图片描述](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210509190545640.gif)

```python
def selectionSort(arr):
    if arr==[] or len(arr)<2:
        return arr
    for i in range(len(arr)-1):# 0~N-1
        minIndex=i
        for j in range(i+1,len(arr)):# 寻找每次的最小值
            minIndex=j if arr[j]<arr[minIndex] else minIndex
        arr[i],arr[minIndex]=arr[minIndex],arr[i]
    return arr
```

**时间复杂度、空间复杂度分析**

最好情况（有序）:$O(n^2)$

比较$\frac{n(n-1)}2$、移动0，

最坏情况（逆序）:$O(n^2)$

比较$\frac{n(n-1)}2$、移动n-1；

平均情况:$O(n^2)$

比较$O(n^2)$、移动$O(n)$

### 2.冒泡排序——时间复杂度：$O(N^2)$、空间复杂度：$O(1)$

> 左边大于右边交换一趟排下来最大的在右边，一次排序将最大的排在最右边，进行n-1个排序就排好了
>
> ![在这里插入图片描述](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210509190446264.gif)

```python
def bubbleSort(arr):
    for i in range(len(arr)-1): #进行n-1轮，每轮排好一个数
        for j in range(len(arr)-1-i): #进行每轮的排序，找到最大的数排在最后
            if arr[j]>arr[j+1]:
                arr[j],arr[j+1]=arr[j+1],arr[j]
    return arr
```

#### 冒泡排序的优化

> 可以利用逆序对进行优化比较



```C++
void myBubleSort4(int * nums, int len) {
	bool isSwapped;
	int lastSwap = 0;
	int k = len - 1;
	for (int i = 0; i < len; ++i) {
		isSwapped = false;  //判断还有不有逆序对，没有了就true
		for (int j = 0; j < k; ++j) {
			if (nums[j] > nums[j + 1]) {
				nums[j] = nums[j] ^ nums[j + 1]; //异或运算进行交换
				nums[j + 1] = nums[j + 1] ^ nums[j];
				nums[j] = nums[j] ^ nums[j + 1];
				isSwapped = true;
				//lastSwap之后的数都是排好序的
				lastSwap = j;
			}
		}
		if (!isSwapped) break; //没逆序对了，就停止
		k = lastSwap;
	}
}
```

#### 冒泡排序的应用

**最多交换k次冒泡排序**

冒泡排序通过交换相邻元素来调整元素的顺序

### 3.插入排序——时间复杂度：$O(N^2)$、空间复杂度：$O(1)$

> 相当于抽牌，每取一个数，就与前面数做对比，如果小就往前走，找到小于或等于，插入即可
>
> ![在这里插入图片描述](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210223174254141.gif)

```python
def insertionSort(arr):
    for i in range(len(arr)):
        for j in range(i,0,-1):
            if arr[j-1]>arr[j]:
                arr[j],arr[j-1]=arr[j-1],arr[j]
    return arr
```

#### 插入排序的改进：折半插入排序、希尔排序

折半插入排序是采用折半查找的方法，可以更快地寻找插入位置，减少关键码的比较次数。但是他并不能减少排序元素的移动次数。比较次数为$O(NlogN)$、移动次数为$O(logN^2)$



### 希尔排序

>1.先选定一个小于N的整数gap作为第一增量，然后将所有距离为gap的元素分在同一组，并对每一组的元素进行直接插入排序。然后再取一个比第一增量小的整数作为第二增量，重复上述操作…
>2.当增量的大小减到1时，就相当于整个序列被分到一组，进行一次直接插入排序，排序完成。
>
>![在这里插入图片描述](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210509190237603.gif)

**代码如下**

```
//希尔排序
void ShellSort(int* arr, int n)
{
	int gap = n;
	while (gap>1)
	{
		//每次对gap折半操作
		gap = gap / 2;
		//单趟排序
		for (int i = 0; i < n - gap; ++i)
		{
			int end = i;
			int tem = arr[end + gap];
			while (end >= 0)
			{
				if (tem < arr[end])
				{
					arr[end + gap] = arr[end];
					end -= gap;
				}
				else
				{
					break;
				}
			}
			arr[end + gap] = tem;
		}
	}
}

```



### 4.归并排序——时间复杂度：$O(NlogN)$、空间复杂度：$O(N)$

**前提知识：分治思想（递归）**

**分治思想**

> **分解步骤**将问题划分为一些子问题，子问题的形式和原问题一样，只是规模更小。
>
> **解决步骤**递归地求解出子问题。如果子问题的规模足够小，则停止递归，直接求解。
>
> **合并步骤**将子问题的解组合成原问题的解。

<img src="%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231005140333751.png" alt="image-20231005140333751" style="zoom:50%;" />

```java
public class GetMax{
    public static int getMax(int[] arr){
        return process(arr,0,arr.length-1);
    }
    //arr[L..R]范围上求最大值 
    public static int process(int[]arr,int L,int R){
        if(L==R){//arr[L..R]范围上只有一个数，直接返回，base case
            return arr[L];
        }
        int mid=L+((R-L)>>1);//中点 
        int leftMax=process(arr,L,mid);
        int rightMax=process(arr,mid+1,R);
        return Math.max(leftMax,rightMax);
    }
}
```

> 中点有三种求法：
>
> 1.mid=$\frac{L+R}{2}$ **这种求法可能导致L+R溢出int范围，可能算出负的下标**
>
> 2.mid=$L+\frac{R-L}{2}$**这种求法不会溢出,补充：$\frac{L}{2}+\frac{R}{2}$如果出现奇数有问题**
>
> 3.mid=$L+(R-L)>>1$**这种求法是2的简化,(R-L)右移一位相当于除2**

#### ==<font size=5>**Master 公式(一个递归，母问题规模为N，子问题规模都为N/b)：**</font>==

==**$T(N)=a*T(\frac{N}b)+O(N^d)$**==
$$
\begin{cases}
O(N^d)&log_ba<d\\
\\
O(N^{log_ba})&log_ba>d\\
\\
O(N^d*logN)&log_ba=d
\end{cases}
$$
**归并排序：**

>  归并排序的基本思想（分治思想）：
>
> 1、（拆分）将一段数组分为左序列和右序列，让他们两个分别有序，再将左序列细分为左序列和右序列，如此重复该步骤，直到细分到区间不存在或者只有一个数字为止
>
> 2、（合并）将第一步得到的数字合并成有序区间
>
> ![img](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/1a63567f7ebb40479e25919faf3cf131.gif)

```python
# 定义一个合并函数，用于将两个有序的子数组合并为一个有序的数组
def merge(arr, left, mid, right):
    # 创建一个辅助数组
    temp = []
    # 初始化两个指针，分别指向两个子数组的起始位置
    i = left
    j = mid + 1
    # 比较两个子数组的元素，并将较小的元素放入辅助数组中
    while i <= mid and j <= right:
        if arr[i] <= arr[j]:
            temp.append(arr[i])
            i += 1
        else:
            temp.append(arr[j])
            j += 1
    # 将剩余的元素放入辅助数组中
    while i <= mid:
        temp.append(arr[i])
        i += 1
    while j <= right:
        temp.append(arr[j])
        j += 1
    # 将辅助数组中的元素复制回原数组中
    for i in range(left, right + 1):
        arr[i] = temp[i - left]

# 定义一个归并排序函数，用于递归地对数组进行分解和合并
def merge_sort(arr, left, right):
    # 如果左边界小于右边界，说明还可以继续分解
    if left < right:
        # 计算中间位置
        mid = left+((right-left)>>1)
        # 对左半部分进行归并排序
        merge_sort(arr, left, mid)
        # 对右半部分进行归并排序
        merge_sort(arr, mid + 1, right)
        # 将两个有序的子数组合并为一个有序的数组
        merge(arr, left, mid, right)
```

```java
public static void mergeSort(int[] arr){
	if(arr==null || arr.length<2){
        return;
    }
    process(arr,0,arr.length-1);
}
public static void process(int[] arr, int L, int R){
    if(L==R){
        return ;
    }
    int mid =L+((R-L)>>1);
    process(arr,L,mid);
    process(arr,mid+1,R);
    merge(arr,L,mid,R);
}
public static void merge(int[] arr, int L, int M, int R){
	int[] help =new int[R-L+1];
    int i=0;
    int p1=L;
    int p2=M+1;
    while (p1<=M && p2<=R){
        help[i++]=arr[p1]<=arr[p2]?arr[p1++]:arr[p2++];
    }
    while(p1<=M){
        help[i++]=arr[p1++];
    }
    while(p2<=R){
        help[i++]=arr[p2++];
    }
    for (i=0;i<help.length;i++){
        arr[L+i]=help[i]
    }
}
```

#### 归并排序的扩展

##### 1.小和问题

在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。

eg:[1,3,4,2,5] 1左边比1小的数，没有；3左边比3小的数为1；4左边：1、3；2左边：1；5：1、3、4、2

所以小和为1+1+3+1+1+3+4+2=16



```python
class Small_Sum():
    def small_sums(self,li):

        if li is None or len(li)<2:
            return 0
        return self.small_sum(li,0,len(li)-1)
#进行递归的函数
    def small_sum(self,li,l,r):
        if l == r:
                return 0
        mid = l + ((r-l) // 2)
        # l = self.small_sum(li,l,mid)
        # r = self.small_sum(li,mid+1,r)
        return self.small_sum(li,l,mid) + self.small_sum(li,mid+1,r) + self.merge(li,l,mid,r)
#找出小和与排序
    def merge(self,li,l,mid,r):
        res = 0
        help = []  #定义临时列表来暂时存储元素
        p1 = l #两个指针
        p2 = mid+1
        while p1 <= mid and p2 <= r:
            res += (r - p2 + 1) * li[p1] if li[p1] < li[p2] else 0
            if li[p1] < li[p2]:
                help.append(li[p1])
                p1+=1
            else:
                help.append(li[p2])
                p2+=1
#两个循环只能进去一个
        while p1 <=mid:
            help.append(li[p1])
            p1 +=1
 
        while p2 <= r:
            help.append(li[p2])
            p2 +=1
        li[l:r+1] = help
        return res  #返回小和
 #测试样例
if __name__ == '__main__':
    li = [1,3,4,2,5]
    ss = Small_Sum()
 
    sum = ss.small_sums(li)
    print(sum)
```



##### 2.逆序对问题

在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对，请打印所有逆序对。

```python
def inversion(arr):
    if arr is None or len(arr)<2:
        return 
    merge_sort(arr,0,len(arr)-1)
def merge(arr, left, mid, right):
    # 创建一个辅助数组
    temp = []
    # 初始化两个指针，分别指向两个子数组的起始位置
    i = left
    j = mid + 1
    # 比较两个子数组的元素，并将较小的元素放入辅助数组中
    while i <= mid and j <= right:
        if arr[i] <= arr[j]:
            temp.append(arr[i])
            i += 1
        else:#当左边一个大时，说明从左边那个开始右边的都大，都是逆序对
            for k in range(i,mid+1): #由于sort 会导致比较的那一个会merge到temp中，所以必须用for来打印
                print(f"<{arr[k]},{arr[j]}>")
            temp.append(arr[j])
            j += 1        
    # 将剩余的元素放入辅助数组中
    while i <= mid:
        temp.append(arr[i])
        i += 1
    while j <= right:
        temp.append(arr[j])
        j += 1
    # 将辅助数组中的元素复制回原数组中
    for i in range(left, right + 1):
        arr[i] = temp[i - left]
# 定义一个归并排序函数，用于递归地对数组进行分解和合并
def merge_sort(arr, left, right):
    if left== right:
        return    
    # 计算中间位置
    mid = left+((right-left)>>1)
    merge_sort(arr, left, mid)
    merge_sort(arr, mid + 1, right)
    merge(arr, left, mid, right)
```

### 5.快速排序——时间复杂度：优化后$O(NlogN)$，未优化$O(N^2)$、空间复杂度：最好（相当于二叉树）$O(logN)$最差$O(N)$

<font size=4>**引入：荷兰国旗问题**</font>

**问题一**

给定一个数组arr,和一个数num,请把小于等于num的数放在数组的左边,大于num的数放在数组的右边。要求额外空间复杂度O(1),时间复杂度O(N)

**问题二（荷兰国旗问题）**

给定一个数组arr,和一个数num,请把小于等于num的数放在数组的左边,等于num的数放在数组的中间，大于num的数放在数组的右边。要求额外空间复杂度O(1),时间复杂度O(N)

![image-20231005195027117](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231005195027117.png)

> 解法：就如图
>
> （1）当指针i的数小于等于num时，让这个指针的数和小于等于区的下个数作交换，小于等于区外扩，并且指针下移
>
> （2）当指针i的数大于num时，下移
>
> 这样就能解决第一问

![image-20231005195433245](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231005195433245.png)

#### （1）前后指针法(最推荐用这种写法)

> **基本思想：**
>
> 我们定义两个指针cur和prev，选取key值,cur去遍历小于key的值,对prev++,交换cur与prev值,直至cur遍历完整个数组，prev位置的值一定是比key值小的，即key应处的正确位置，==当将key放置在对应位置，则两端将分为大于key，和小于等于key的，则只需要将剩下的两部分继续进行上述步骤即递归即可，相当于每次确定一个数的位置==
>
> **动图展示：**![img](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/740448522c8d41979c87805fb635f7dc.gif)
>
> ==这个也可变为小于等于大于版本==
>
> <img src="%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231005200616749.png" alt="image-20231005200616749" style="zoom:50%;" />

```c++
void swap(int* a,int* b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
void quickSort(int* a,int begin,int end)
{
    if(begin >= end) return;
    int key = begin,pre = begin,cur = begin + 1;
    while(cur <= end)
    {
        while(a[cur] < a[key] && cur != pre)
        {
            swap(&a[cur],&a[++pre]);
        }
        cur++;
    }
    swap(&a[key],&a[pre]);
    key = pre;
    quickSort(a,begin,key - 1);
    quickSort(a,key + 1,end);
}
```

```python
def quickSort(arr,L,R):
    if L>=R:
        return
    if L<R:
       p=partition(arr,L,R)
       quickSort(arr,L,p-1)
       quickSort(arr,p+1,R)
def partition(arr,L,R):
    prev=L
    cur=L+1
    key=L # 选择第一个数作为基准
    while cur<=R:
        while arr[cur]<arr[key] and cur!=prev:
            prev+=1
            arr[prev],arr[cur]=arr[cur],arr[prev]
        cur+=1
    arr[key],arr[prev]=arr[prev],arr[key]
    return prev
```







#### (2)hoare版本快排——学校用的这个版本

> 基本思想：
>
> 我们将左边值设为key,然后右边right先走,找小的,比key小停下来,然后左边left走找比key大,然后交换左边右边，继续上述过程，直至left和right相遇，此时的值一定是比key小的值，我们再把key和这个相遇位置的值进行交换，此时key所在的位置，左边的数据一定比key值小，右边的数据一定比key值大，即key放到了合适的位置上。重复此过程进行递归，直至所有的元素都处在合适位置。
>
> 动图展示：![img](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/cde3ba9c95804870af9d4b1553e6b97b.gif)
>
> ![img](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/89bd712e32e9439883554543c52e9cea.gif)

```c++
void swap(int* a,int* b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
void quickSort(int* a,int begin,int end)
{
    if(begin >= end) return;//当begin>=end，结束递归操作
    int L = begin,R = end,key = begin;//定义L,R,key下标
    while(L < R)
    {
        while(a[R] >= a[key] && L < R)//右边先走，右边大于等于key就一直走下去，否则停下来，加上判断L < R，防止越界
        {
            R--;
        }
        while(a[L] <= a[key] && L < R)//同理
        {
            L++; 
        }
        swap(&a[L],&a[R]);//都停下来后交换
    }
    swap(&a[key],&a[R]);//最后key值和相遇点交换
    key = R;//以相遇点作为分界点，递归操作
    quickSort(a,begin,key - 1);//递归
    quickSort(a,key + 1,end);
}
```

#### (3)挖坑法

> 基本思想：
>
> 挖坑法对hoare的思想进行了优化。我们设定key数组左边第一个值为坑,右边right找小,找到比key小的值填到坑位，right就成为新的坑位，然后左边left找大,找到后填到坑位上,left此时更新为新的坑位,循环此过程，right接着找小，left找大，交换形成新的坑位，直至left和right相遇。最后把key放到坑里，即类似于hoare版本key应处于的位置。
>
> 动图展示：
> ![img](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/6669861612704fefa3b98d952d92a98b.gif)

```c++
void quickSort(int* a,int begin,int end)
{
    if(begin >= end) return;
    int L = begin,R = end,key = a[begin];
    int hole = L;
    while(L < R)
    {
        while(a[R] >= key && L < R)
        {
            R--;
        }
        a[hole] = a[R];
        hole = R;
        while(a[L] <= key && L < R)
        {
            L++; 
        }
        a[hole] = a[L];
        hole = L;
    }
    a[hole] = key;
    key = hole;
    quickSort(a,begin,key - 1);
    quickSort(a,key + 1,end);
}
```



#### 快速排序的优化

##### 1.三数取中法、随机选key法--- 随机与三数取中性能比较！

> ==快速排序对于数据是敏感的==，如果这个序列是非常==无序==，杂乱无章的，那么快速排序的效率是非常高的，可是如果数列==有序==，时间复杂度就会从O(N*logN)变为O(N^2)，相当于冒泡排序了
>
> 若每趟排序所选的key都正好是该序列的中间值，即单趟排序结束后key位于序列正中间，那么快速排序的时间复杂度就是O(NlogN)
>
> 但是这是理想情况，当我们面对一组极端情况下的序列，就是有序的数组，选择左边作为key值的话，那么就会退化为O(N^2)的复杂度，所以此时我们选择首位置，尾位置，中间位置的数分别作为三数，选出中间位置的数，放到最左边，这样选key还是从左边开始，这样优化后，全部都变成了理想情况
> ![img](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASGVybyAyMDIx,size_20,color_FFFFFF,t_70,g_se,x_16.png)

**随机选key法**

```python
import random
def quickSort(arr,L,R):
    if L>=R:
        return
    if L<R:
       key=random.randint(L,R)
       arr[L],arr[key]=arr[key],arr[L] #选择随机数作为基准将第一个数与随机数交换
       p=partition(arr,L,R)
       quickSort(arr,L,p-1)
       quickSort(arr,p+1,R)
def partition(arr,L,R):
    prev=L
    cur=L+1
    key=L # 选择随机数作为基准
    while cur<=R:
        while arr[cur]<arr[key] and cur!=prev:
            prev+=1
            arr[prev],arr[cur]=arr[cur],arr[prev]
        cur+=1
    arr[key],arr[prev]=arr[prev],arr[key]
    return prev
```

**三数取中法**

> **基本思想：**
>
> 在待排序数组的左端、右端和中间选择三个元素，并将这三个元素进行排序，将中间值作为枢纽元(pivot)来进行分割。这样可以尽量避免在有序数组中选择极值作为枢纽，从而提高快速排序的效率

```python
def GetMidIndex(arr,L,R):
    mid=L+(R-L)>>1
    if arr[L]<arr[R]:
        if arr[mid]<arr[R]:
            return mid
        elif arr[mid]>arr[R]:
            return R
        else:
            return L
    else:
        if arr[mid]>arr[L]:
            return L
        elif arr[mid]<arr[R]:
            return R
        else:
            return mid
def quickSort(arr,L,R):
    if L>=R:
        return
    if L<R:
       key=GetMidIndex(arr,L,R)
       arr[key],arr[L]=arr[L],arr[key]
       p=partition(arr,L,R)
       quickSort(arr,L,p-1)
       quickSort(arr,p+1,R)
def partition(arr,L,R):
    prev=L
    cur=L+1
    key=L # 选择随机数作为基准
    while cur<=R:
        while arr[cur]<arr[key] and cur!=prev:
            prev+=1
            arr[prev],arr[cur]=arr[cur],arr[prev]
        cur+=1
    arr[key],arr[prev]=arr[prev],arr[key]
    return prev
```

### 6.堆排序——时间复杂度：$O(NlogN)$、空间复杂度：$O(1)$

#### 前提知识——堆（heap）（优先队列-priority queue）

堆要满足两点：

> <font color=orange>堆是一个完全二叉树</font>；
>
> 第一，堆结构必须是一个==完全二叉树==，完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列，自然堆也具有完全二叉树的所有性质。

> <font color=orange>**堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。（即必须未大根堆或小根堆）**</font>
>
> 第二点，堆中的每个节点的值必须大于等于（或者小于等于）其子树中每个节点的值。实际上，我们还可以换一种说法，堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。这两种表述是等价的。

**每个结点的值都大于或等于其左右孩子结点的值**，我们叫做“大根堆”（大顶堆）。

**每个结点的值都小于或等于其左右孩子结点的值**，我们叫做“小根堆”（小顶堆）。

![img](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55qG6Ieq6JC9,size_20,color_FFFFFF,t_70,g_se,x_16.png)

我们设树的根结点为0，给定一个下标i，可以很容易计算得到它的父节点、左孩子、右孩子的下标。
$$
(从0出发)i的\begin{cases}
父结点&\frac {i-1}2\\
左孩子&2\times i+1\\
右孩子&2\times i+2
\end{cases}
$$

#### 维护堆的性质

> heapify 和 heapInsert 是==维护堆==性质的重要过程。两者的时间复杂度都为O(logN),其中heapify是向下调整，heapInsert是向上调整。

```java
//某个数现在在index位置，往上调整
public static void heapInsert(int[] arr,int index){
	while (arr[index]>arr[index-1]/2){
		swap(arr,index,(index-1)/2);
		index=(index-1)/2;
	}
}
```

```java
//某个数现在在index位置，往下调整
public static void heapify(int[] arr,int index,int heapSize){
	int left=index*2+1;//左孩子的下标
	while(left<heapSize){//下方还有孩子的时候
		//两个孩子中，谁的值大，把下标给largest
		int largest =left+1<heapSize &&arr[left + 1]>arr[left]?left+1:left;
		//父和孩子之间，谁的值大，把下标给largest
		largest=arr[largest]>arr[index]?largest:index;
		if(largest==index){
			break;
		}
		swap(arr,largest,index);
		index=largest;
		left=index*2+1
	}
}
```

#### 建堆

> 我们可以用heapify自底向上的方法建立大根堆，当然也可以用heapInsert自上而下的方法建立大根堆，==但是使用heapify建立大根堆的方法更快（实际上只是第一步快一点）,时间复杂度相对更低==，所以一般使用heapify来建立大根堆，时间复杂度可用错位相减法估计为O(N)
>
> ![image-20231008171228843](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231008171228843.png)

```python
def BuildHeap(arr): 
    n=len(arr)
    for i in range(n // 2 - 1, -1, -1):
            heapify(arr, n, i)
```





#### 堆排序

> 堆排序的基本思想是：
>
> 1. 将待排序序列构**造成一个大顶堆**
> 2. 此时，整个序列的**最大值**就是**堆顶的根节点**。
> 3. 将其与**末尾元素进行交换**，此时末尾就为最大值。
> 4. 然后将**剩余n-1个元素重新构造成一个堆**，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。

```python
# 定义一个函数，用于调整指定节点及其子树为最大堆
def heapify(arr, n, i):
    # 初始化最大值的索引为当前节点
    largest = i
    # 计算左右子节点的索引
    left = 2 * i + 1
    right = 2 * i + 2
    # 如果左子节点存在且大于当前最大值，更新最大值的索引
    if left < n and arr[left] > arr[largest]:
        largest = left
    # 如果右子节点存在且大于当前最大值，更新最大值的索引
    if right < n and arr[right] > arr[largest]:
        largest = right
    # 如果最大值的索引不是当前节点，交换它们的位置，并递归调整被交换的子树
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

# 定义一个函数，用于实现堆排序
def heap_sort(arr):
    # 获取数组的长度
    n = len(arr)
    # 从最后一个非叶子节点开始，自下而上构建最大堆
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    # 从最后一个元素开始，自右而左交换堆顶元素和堆尾元素，并调整剩余的元素为最大堆
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)
```

```java
public static void heapSort(int[] arr){
	if(arr==null||arr.length<2){
		return;
	}
    // 建立大根堆
	for(int i=0;i<arr.length;i++){// O(N)
		heapInsert(arr,i);	//O(logN)
	}
	int heapSize=arr.length;
	swap(arr,0,--heapSize);//先减再做交换，因为数组长度-1才是有效下标
	while(heapSize>0){//O(N)
		heapif(arr,0,heapSize);//O(logN)
		swap(arr,0,--heapSize);
	}
}
```

#### 堆排序扩展题目

已知一个几乎有序的数组，几乎有序是指，如果把数组排号顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数组进行排序。

> 利用小根堆，每次在k元素内建立小根堆，弹出最小值，放在最前的位置，重复即可，时间复杂度为O(Nlogk)

```java
public void sortedArrDistanceLessK(int[] arr, int k){
	//默认小根堆
	PriorityQueue<Integer> heap = new PriorityQueue<>();
	int index =0;
	for (;index<=Math.min(arr.length,k);index++){
		heap.add(arr[index]);
	}
	int i=0;
	for (;index<arr.length;i++,index++){
		heap.add(arr[index]);
		arr[i]=heap.poll();
	}
	while(!heap.isEmpty()){
		arr[i++]=heap.poll();
	}
}
```



### 线性时间排序（不基于比较的排序）

### 7.桶排序——时间复杂度：最好$O(N+K)$ 最坏$O(N^2)$、空间复杂度$O(N+K)$

> **1、算法原理：**
>
> 桶排序的核心思想就是==将要排序的数据分到几个有序的桶里==，每个桶里的数据再单独进行排序。桶排序完之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。
>
> **2、图片演示：**
>
> ![在这里插入图片描述](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20200622162250898.gif)
>
> 3、**算法分析**：
>
> 如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用归并排序，时间复杂度为 O(k * logk)。==m 个桶排序的时间复杂度就是 O(m * k * logk)==，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度==接近 O(n)==。
>
> 所以，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少，但相应的空间消耗就会增大。 
>
> 4、**桶排序的使用条件和适用场景**：
>
> 桶排序对要排序的数据的要求是非常苛刻的。使用条件如下：
>
> （1）首先，要排序的数据需要很容易就能划分成m个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内数据都排序完之后，桶与桶之间的数据不需要在进行排序。
>
> （2）其次，数据在各个桶之间的分布比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。
>
> 所以，桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。
>
> 5、**应用案例**：
>
> （1）需求描述：有10GB的订单数据，需按订单金额（假设金额都是正整数）进行排序，但内存有限，仅几百MB。
>
> （2）解决思路：
>
> > 扫描一遍文件，看订单金额所处数据范围，比如1元-10万元，那么就分100个桶。
> >
> > 第一个桶存储金额1-1000元之内的订单，第二个桶存1001-2000元之内的订单，依次类推。
> >
> > 每个桶对应一个文件，并按照金额范围的大小顺序编号命名（00，01，02，…，99）。
> >
> > 将100个小文件依次放入内存并用快排排序。
> >
> > 所有文件排好序后，只需按照文件编号从小到大依次读取每个小文件并写到大文件中即可。
> >
> > 注意点：若单个文件无法全部载入内存，则针对该文件继续按照前面的思路进行处理即可。
> > 

### 8.计数排序——时间复杂度$O(N+K)$、空间复杂度$O(N+K)$

> 1、**算法原理**：
>
> ==计数排序可以看成是桶排序的一种特殊情况==，只是桶的大小粒度不一样。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。
>
> 2、**适用场景**：
>
> ==计数排序只能用在数据范围不大的场景中==，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。
>
> 3、**动图演示**：
>
> ![img](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20181219185934399)
>
> 4、**算法分析**：
>
> 计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。

```C++
#include <iostream>
#include <vector>
using namespace std;

// 定义一个计数排序函数，参数为一个整数向量
void counting_sort(vector<int>& nums) {
    // 找出向量中的最大值和最小值
    int max_num = nums[0];
    int min_num = nums[0];
    for (int num : nums) {
        max_num = max(max_num, num);
        min_num = min(min_num, num);
    }
    // 创建一个计数向量，大小为最大值和最小值的差加一
    vector<int> count(max_num - min_num + 1, 0);
    // 遍历原向量，对每个元素在计数向量中对应的位置加一
    for (int num : nums) {
        count[num - min_num]++;
    }
    // 遍历计数向量，将每个元素按照出现的次数依次放回原向量
    int index = 0;
    for (int i = 0; i < count.size(); i++) {
        while (count[i] > 0) {
            nums[index++] = i + min_num;
            count[i]--;
        }
    }
}

int main() {
    int n; // 输入的整数个数
    cin >> n; // 输入整数个数
    vector<int> nums(n); // 创建一个存储整数的向量
    for (int i = 0; i < n; i++) {
        cin >> nums[i]; // 输入每个整数
    }
    counting_sort(nums); // 对整数进行计数排序
    for (int num : nums) {
        cout << num << " "; // 输出排序后的整数
    }
    cout << endl;
    return 0;
}
```



### 9.基数排序——时间复杂度$O(N\times K)$、空间复杂度$O(N+K)$

> 1、**算法原理**：
>
> ==基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集==；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。
>
> 2、**使用条件**：
>
> ==基数排序对要排序的数据是有要求的==，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，因为==基数要借助桶排序或者计数排序算法==来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。
>
> 3、**动图演示**：
>
> ![img](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20181219185934456)
>
> 4、**算法分析**：
>
> （1）基数排序基于分别排序，分别收集，所以是稳定的。
>
> （2）如果要排序的数据有 k 位，那我们就==需要 k 次桶排序或者计数排序==，总的时间复杂度是 ==O(k*n)==。当 k 不大的时候，比如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于 O(n)。
>
> （3）基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n>>k，因此额外空间需要大概n个左右。

**代码如下：**

```C++
#include <iostream>
#include <vector>
#include <queue>
#include<cmath>
using namespace std;

// 定义一个基数排序函数，参数为一个整数向量
void radix_sort(vector<int>& nums) {
    // 找出向量中的最大值
    int max_num = nums[0];
    for (int num : nums) {
        max_num = max(max_num, num);
    }
    // 计算最大值的位数
    int digits = 0;
    while (max_num > 0) {
        digits++;
        max_num /= 10;
    }
    // 创建一个存储0-9的队列数组
    vector<queue<int>> buckets(10);
    // 从低位到高位进行排序
    for (int i = 0; i < digits; i++) {
        // 遍历原向量，将每个元素按照当前位的数字放入对应的队列中
        for (int num : nums) {
            int digit = (num / (int)pow(10, i)) % 10; // 计算当前位的数字
            buckets[digit].push(num); // 将元素放入队列中
        }
        // 遍历队列数组，将每个队列中的元素依次放回原向量
        int index = 0;
        for (int j = 0; j < 10; j++) {
            while (!buckets[j].empty()) {
                nums[index++] = buckets[j].front(); // 取出队列首元素放入原向量
                buckets[j].pop(); // 弹出队列首元素
            }
        }
    }
}

int main() {
    int n; // 输入的整数个数
    cin >> n; // 输入整数个数
    vector<int> nums(n); // 创建一个存储整数的向量
    for (int i = 0; i < n; i++) {
        cin >> nums[i]; // 输入每个整数
    }
    radix_sort(nums); // 对整数进行基数排序
    for (int num : nums) {
        cout << num << " "; // 输出排序后的整数
    }
    cout << endl;
    return 0;
}

```



### 排序算法总结

**常见数据结构排序算法的时间复杂度、空间复杂度、稳定性**

![img](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/7f0a072a02f34c3fbae49708575f365d.webp)

![image-20231016084233401](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231016084233401.png)

### 比较器的使用

**1）比较器的实质就是重载比较运算符**

**2）比较器可以很好的应用在特殊标准的排序上**

**3）比较器可以很好的应用在根据特殊标准排序的结构上**



**形式**

C++:

```C++
#include<algorithm> //需要用algorithm库
//降序
bool compare(int a,int b){
	return a>b;
}
sort(arr.begin(),arr.end(),compare);
```

Java:

```java
import java.util.Arrays;

public class Comparator {

	public static void main(String[] args) {
		int[] arr= {1,0,9,6,2,5,6,7,2,5};
		Arrays.sort(arr);
		System.out.println(Arrays.toString(arr));
	}
}

```

**类型**

```C++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// 定义一个结构体，存储学生的学号，语文成绩和数学成绩
struct Student {
    int id; // 学号
    int chinese; // 语文成绩
    int math; // 数学成绩
};

// 定义一个比较函数，用于排序
bool compare(Student a, Student b) {
    // 如果语文成绩不同，按语文成绩降序排序
    if (a.chinese != b.chinese) {
        return a.chinese > b.chinese;
    }
    // 如果语文成绩相同，但数学成绩不同，按数学成绩降序排序
    if (a.math != b.math) {
        return a.math > b.math;
    }
    // 如果语文成绩和数学成绩都相同，按学号升序排序
    return a.id < b.id;
}

int main() {
    int n; // 学生数量
    cin >> n; // 输入学生数量
    vector<Student> students(n); // 创建一个存储学生的向量
    for (int i = 0; i < n; i++) {
        cin >> students[i].id >> students[i].chinese >> students[i].math; // 输入每个学生的信息
    }
    sort(students.begin(), students.end(), compare); // 对学生进行排序
    for (int i = 0; i < n; i++) {
        cout << students[i].id << endl; // 输出每个学生的学号
    }
    return 0;
}
```



## 三、链表

### 1.哈希表(散列表)的简单介绍

> 1）哈希表在使用层面上可以理解为一种集合结构
>
> 2）如果只有key，没有伴随数据value，可以使用HashSet结构（C++中叫UnOrderedSet）
>
> 3）如果既有key，又有伴随数据value，可以使用HashMap结构（C++中叫UnOrderedMap）
>
> 4）有无伴随数据，是HashMap和HashSet唯一的区别，底层的实际结构是一回事
>
> 5）使用哈希表增（put）、删（remove）、查（get）、改（put）的操作，可以认为时间复杂度为==O（1）==，但是常数时间比较大
>
> 6）放入哈希表的东西，如果是基础类型，内部按==值==传递，内存占用就是这个东西的大小（**相当于深拷贝，把值给拷贝了**）
>
> 7）放入哈希表的东西，如果不是基础类型，内部按==引用==传递，内存占用时这个东西内存地址的大小(**相当于浅拷贝，引用**)

### 2.有序表的简单介绍

> 1）有序表在使用层面上可以理解为一种集合结构
>
> 2）如果只有key，没有伴随数据value，可以使用TreeSet结构（C++中叫OrderedSet）
>
> 3）如果既有key，又有伴随数据value，可以使用TreeMap结构（C++中叫OrderedMap）
>
> 4）有无伴随数据，是HashMap和HashSet唯一的区别，底层的实际结构是一回事
>
> 5）红黑树、AVL数、size-balance-tree和跳表等都属于有序表结构，只是底层具体实现不同
>
> 6）放入哈希表的东西，如果是基础类型，内部按==值==传递，内存占用就是这个东西的大小（**相当于深拷贝，把值给拷贝了**）
>
> 7）放入哈希表的东西，如果不是基础类型，内部按==引用==传递，内存占用时这个东西内存地址的大小(**相当于浅拷贝，引用**)
>
> 8）不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复杂度

![image-20231007172149804](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231007172149804.png)

### 3.链表

> **一、链表定义**
> 链表是由一系列连接在一起的结点构成，其中的**每个结点**都是**一个数据结构**。
> 链表的结点通常是动态分配、使用和删除的，允许链表在程序运行时增大或缩小。如果需要将新信息添加到链表中，则程序只需分配另一个结点并将其插入到系列中。如果需要从链表中删除特定的信息块，则程序将删除包含该信息的结点。
>
> **二、链表的结构**
>
> ##### 2.1 单个节点的组成
>
> 链表的每个节点，除数据之外还包含一个后继指针指向链表中的下一个节点。
>
> ![链表单个节点的组成](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/2bf369f67b0148258cfcdcd6275493a1.png)
>
> 三、链表的种类
> 在实际中，链表有许多形式，根据单向、双向；带头、不带头；循环、非循环的排列组合，就有八种形式的链表。
> 下面举几个常见的链表：
>
> 不带头单链表
>
> <img src="%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/b39dd3b31b644f77ac1959a67ef4b63d.png" alt="在这里插入图片描述"  />
>
> 不带头双向链表
>
> ![在这里插入图片描述](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/1a42fd49712949c0b3c84d68badde38d.png)
>
> 带头单链表
>
> ![在这里插入图片描述](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/6fe23fca88a44015879f8209dde6826b.png)
>
> 循环单链表
>
> ![在这里插入图片描述](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/0daa877f7f09484394087ec7a26375bf.png)
>
> 带头双向循环链表
>
> ![在这里插入图片描述](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/3cfe70d45ee444aba9ac3bf3c550b8b3.png)

#### 单向链表的代码实现（C++）

##### 一、链表定义（struct）

下面的结构体定义了C++语言中的一种常见的链表节点，包括数据、指针和两种不同类型的构造函数。

```C++
struct ListNode {
    int val;        //存储数据
    ListNode *next; //next指针
    ListNode() : val(0), next(nullptr) {}  //类似构造函数
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
```

##### 二、节点创建

```C++
int main()
{
    ListNode *node1 = new ListNode;
    ListNode *node2 = new ListNode();   // 初始化值为0
 	ListNode *node3 = new ListNode(100); // 初始化值为100

 	cout<< node1->val<<endl;
 	cout<< node2->val<<endl;
    cout<< node3->val<<endl;

    return 0;
}
```

##### 三、插入节点

```C++
int main()
{
 	ListNode *node1 = new ListNode(100); // 初始化值为-1
 	ListNode *node2 = new ListNode(200); // 初始化值为-1

 	node1->next=node2;

 	cout<< node1->next->val<<endl;
    return 0;
}
```

##### 四、循环建立链表

```C++
int main()
{
 	ListNode *head = new ListNode(); //头节点
    ListNode *p=head;                //指针
    int i=1;
    while(i<5){
        ListNode *node = new ListNode(i); // 初始化一个节点
        p->next = node;
        p=p->next;
        i++;
    }
    p->next=NULL;//最后一个节点的指针指向空
    return 0;
}
```

##### 五、遍历链表

```C++
int main()
{
 	ListNode *head = new ListNode(); //头节点
    ListNode *p=head;                //指针
    int i=1;
    while(i<5){
        ListNode *node = new ListNode(i); // 初始化一个节点
        p->next = node;
        p=p->next;
        i++;
    }
    p->next=NULL;//最后一个节点的指针指向空
     
    //遍历链表部分
    p=head;
    while(p){
        cout<<p->val;
        p=p->next;
    }
    
    return 0;
}
```

##### 六、删除节点

```C++
int main()
{
 	ListNode *head = new ListNode(); //头节点
    ListNode *p=head;                //指针
    int i=1;
    while(i<5){
        ListNode *node = new ListNode(i); // 初始化一个节点
        p->next = node;
        p=p->next;
        i++;
    }
    p->next=NULL;//最后一个节点的指针指向空
    p=head;

    //删除第二个节点
    ListNode *pre = p->next;
    p->next=p->next->next;
    delete pre;
   	return 0;
}
```

#### 双向链表的实现

##### 一、链表定义（struct）

下面的结构体定义了C++语言中的一种常见的链表节点，包括数据、指针和两种不同类型的构造函数。

```C++
struct DoubleListNode{
    int val; //存储数据
    DoubleListNode *next=nullptr; //next指针指向下一结点
    DoubleListNode *pre=nullptr;//pre指针指向上一结点
    DoubleListNode() : val(0),next(nullptr),pre(nullptr){}
    DoubleListNode(int x):val(x),next(nullptr),pre(nullptr){}
};
```

##### 二、节点创建

```C++
int main()
{
    DoubleListNode *node1=new DoubleListNode;
    DoubleListNode *node2=new DoubleListNode();
    DoubleListNode *node3=new DoubleListNode(100);
    cout<<node1->val<<endl;
    cout<<node2->val<<endl;
    cout<<node3->val<<endl;

    return 0;
}
```

##### 三、插入节点

```C++
int main()
{
 	DoubleListNode *node1 = new DoubleListNode(100); // 初始化值为-1
 	DoubleListNode *node2 = new DoubleListNode(200); // 初始化值为-1

 	node1->next=node2;

 	cout<< node1->next->val<<endl;
    return 0;
}
```

##### 四、循环建立链表

```C++
int main()
{
 	DoubleListNode *head=new DoubleListNode();
    DoubleListNode *p=head;
    for(int i=1;i<5;i++){
        DoubleListNode *temp=new DoubleListNode(i);
        p->next=temp;
        temp->pre=p;
        p=p->next;
    }
    p=head;
    return 0;
}
```

##### 五、遍历链表

```C++
int main()
{
 	DoubleListNode *head=new DoubleListNode();
    DoubleListNode *p=head;
    for(int i=1;i<5;i++){
        DoubleListNode *temp=new DoubleListNode(i);
        p->next=temp;
        temp->pre=p;
        p=p->next;
    }
    p=head;
    //正向遍历
    while (p)
    {
        cout<<p->val;
        p=p->next;
    }
    // p=p->pre; 当p指针已经指向了链表的最后一个结点，这时p指针已经是一个空指针，那么这一句就没用
    cout<<endl;
    p=head;
    while(p->next)
    {
        p=p->next;
    }
    //反向遍历
    while (p)
    {
        cout<<p->val;
        p=p->pre;
    }
}
```

##### 六、删除节点

略，与单向链表一样

#### 链表常见题

#### 一、反转单向和双向链表

#### 1、反转单向链表

##### 1、迭代反转

> - 定义一个指针 cur，用来遍历链表
> - 定义一个指针 prev，保存 cur 的上一个节点的位置，初始指向 NULL
> - 定义一个指针 next(temp)，保存 cur 的下一个节点的位置，用来迭代![image-20210831161758939](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210831161759.png)
> - 通过 prev 和 cur 来调整每个节点指针的方向，next 进行迭代
> - ![image-20210831165901352](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210831165901.png)

**代码如下：**

```C++
ListNode* reverseList1(ListNode* head) {
     if(head==nullptr || head->next==nullptr){
        return head;
    }
    ListNode* pre = nullptr;  // 定义 pre 指针，初始化为 nullptr；
    ListNode* cur = head;  // 定义 cur 指针，指向头结点；
    //迭代反转，利用三个指针，当cur从头结点移动到尾结点停止
    while(cur) {
        ListNode* tmp = cur->next;  // 定义 temp 指针，指向 cur->next 节点
        cur->next = pre;//将头指向null
        // 后移 pre 和 cur 指针
        pre = cur;  
        cur = tmp;
    }
    return pre;
}
```

![image-20231015164339649](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231015164339649.png)

##### 2、头插法

> 把链表中的所有节点依次头插到一个新链表中，相当于反转了原链表
>
> - 定义一个指针 cur，用来遍历原链表
>
> - 定义一个指针 next，保存 cur 的下一个节点的位置
>
> - 定义一个指针 newhead，指向新链表的头节点
>
>   ![反转链表](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210901234402.gif)

**代码如下**

```C++
// 头插法
ListNode* reverseList2(ListNode* head){
    if(head==nullptr || head->next==nullptr){
        return head;
    }
    ListNode* cur=head;
    ListNode* newhead=nullptr;
    while (cur)
    {
        //next 保存当前cur所在结点的下一个结点的位置
        ListNode* next=cur->next;
        cur->next=newhead;//开始头插
        newhead=cur;//更新头结点
        cur=next;//cur指向下一个待插入的节点
    }
    return newhead;
    
}
```

![image-20231015164541012](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231015164541012.png)

##### 3、就地逆转法

> **一、若有头结点**
>
> 就地逆置法和头插法的实现思想类似，唯一的区别在于，头插法是通过建立一个新链表实现的，而就地逆置法则是直接对原链表做修改，从而实现将原链表反转
>
> ![img](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/f6b9f4816a1d45049cd5b2d31708d67f.png)
>
> <img src="%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/a56d42cbfe9248d18e7031394fbf4950.png" alt="img" style="zoom:50%;" />
>
> ![img](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/cec794ecf4314233bd2037d520fee8fa.png)
>
> **二、若无头结点**
>
> ![img](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/0e412961c90f4767ad5b1f68490db24f.png)
>
> ![img](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/c9d54c3cdb93453bb988ab875f8ca9b3.png)

**代码如下**

```C++
// 就地逆转法 有头结点
ListNode* reverseList3(ListNode* head){
    if(head==nullptr || head->next==nullptr){
        return head;
    }
    ListNode* pre=head->next;
    ListNode* cur=head->next->next;
    
    while (cur!=nullptr)
    {
        pre->next=cur->next;//将cur从链表中摘除
        cur->next=head->next;//将cur移动至链表头，将cur的下一个指向pre
        head->next=cur;//将头指向cur
        cur=pre->next;//将cur调整至pre的下一个
    }
    return head;
    

}
//就地逆转法 无头结点
ListNode* reverseList32(ListNode* head){
    if(head==nullptr || head->next==nullptr){
        return head;
    }
    ListNode* pre=head;
    ListNode* cur=head->next;
    
    while (cur!=nullptr)
    {
        pre->next=cur->next;//将cur从链表中摘除
        cur->next=head;//将cur移动至链表头，将cur的下一个指向pre
        head=cur;//将头指向cur
        cur=pre->next;//将cur调整至pre的下一个
    }
    return head;
    

}
```

![image-20231015170435870](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231015170435870.png)

##### 4、递归反转

>**实现思想:**
>
>从链表的尾结点开始，依次向前遍历，遍历过程依次改变各结点的指向，即令其指向前一个结点。这种方法一般会在函数中建立一个新的头指针，通过层层递进的方式找到链表尾结点，然后将新的头指针指向尾结点，再层层返回把每个遍历后的结点都指向上一个结点，最后令原先的头结点指向NULL，使其成为链表反转后，新链表的尾结点，并返回新的头指针。
>
>![img](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/v2-f26f04e3c58f44ec4d0e98965669283d_1440w.webp)
>
>![img](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/v2-6d13f5c9fbf9f2df6da862185be61d8b_1440w.webp)
>
>![img](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/v2-16a415df23196b6a9d5f724b40e6e4c2_1440w.webp)

**代码如下**

```C++
//递归反转法
ListNode* reverseList4(ListNode* head){
    if(head==nullptr || head->next==nullptr){
        return head;
    }
    ListNode* newhead=reverseList4(head->next);
    head->next->next=head;
    head->next=nullptr;
    return newhead;
}
```

![image-20231015170528579](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231015170528579.png)

#### 2、反转双向链表

双向链表的反转与单向链表原理类似，只是双向链表多了一个指针，则需多一个指针记录前一结点。

```C++
DoubleListNode* reverseDoubleList1(DoubleListNode* head){
    DoubleListNode *cur=NULL;
    DoubleListNode *prev=NULL;
    while (head)
    {
        cur=head->next;//记录下一个结点
        //将结点的两指针反向
        head->next=prev;
        head->pre=cur;
        //记录当前结点，方便指前一个结点
        prev=head;
        //将head指针移动至下个结点
        head=cur;
    }
    return prev;
}
```

#### 二、打印两个有序链表的公共部分

给定两个有序链表的头指针head1和head2，打印两个链表的公共部分

> 从头结点开始，不等时移动小的指针，相等时输出即可
>
> <img src="%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231013093408460.png" alt="image-20231013093408460" style="zoom: 33%;" />

```C++
while(p1!=nullptr && p2!=nullptr){
        if(p1->val==p2->val){
            cout<<p1->val;
            p1=p1->next;
            p2=p2->next;
        }
        if(p1->val<p2->val){
            p1=p1->next;
        }
        if(p1->val>p2->val){
            p2=p2->next;
        }
    }
```

#### 三、判断一个链表是否为回文结构

给定一个单链表的头节点head，请判断该链表是否为回文结构。

**第一种解法：利用栈，容易写，像笔试建议写，空间复杂度O（N）**

```C++
bool isPalindrome1(ListNode *head){
    stack<ListNode*> stk;
    ListNode *cur=head;
    //将链表结点压栈
    while (cur)
    {
        stk.push(cur);
        cur=cur->next;
    }
    //出栈与链表比对
    while (head)
    {
        if(head->val!=stk.top()->val){
            return false;
        }
        stk.pop();
        head=head->next;
    }
    return true;
}
```

![image-20231015171204192](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231015171204192.png)

**第二种解法：快慢指针+栈，空间复杂度O(N)**

> 借助栈结构和双指针，一个指针的位移为1并将此时访问的元素放到栈中，另一个指针的位移为2，当位移为2的指针到达末尾时，位移为1的指针到达链表中间位置。此后将栈中元素与链表中元素值比对。

代码如下：

```C++
//法二，利用栈+快慢指针 O(n/2)
bool isPalindrome2(ListNode* head){
    if(head->next==NULL){
        return true;
    }
    stack<ListNode*> stk;
    //使用双指针
    ListNode* right=head->next;
    ListNode* cur=head;
    // cur走两步,right 走到中点
    while (cur->next!=nullptr && cur->next->next !=nullptr)
    {
        right=right->next;
        
        cur=cur->next->next;
    }
    //将剩下的压入栈
    while (right)
    {
        stk.push(right);
        
        right=right->next;
    }
    //比对前半与后半
    while (!stk.empty())
    {
        
        if(head->val!=stk.top()->val){
            return false;
        }
        stk.pop();
        head=head->next;
    }
    return true;
}
```

![image-20231015171506049](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231015171506049.png)

**第三种解法：只用快慢指针，麻烦，一般笔试不要写，浪费时间，空间复杂度O(1)**

> 利用快慢指针找到中间，然后将中间指向null，将后半部分逆序，最后比对
>
> ![image-20231013112527196](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231013112527196.png)
>
> ![image-20231013112548129](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231013112548129.png)



代码如下：

```C++
//法三：利用快慢指针 O(1)
bool isPalindrome3(ListNode* head){
    if(head->next==NULL){
        return true;
    }
    ListNode* p1=head;
    ListNode* p2=head;
    // p1走到中间，p2走到最后
    while (p2->next!=nullptr && p2->next->next!=nullptr)
    {
        p1=p1->next;
        p2=p2->next->next;
    }
    p2=p1->next; 
    p1->next=nullptr; //将中间指向null
    ListNode* p3=nullptr;
    //将后半部分逆序
    while (p2!=nullptr)
    {
        p3=p2->next;//记录下一个
        p2->next=p1;//将指针反转
        //两个指针往后移
        p1=p2;
        p2=p3;
    }
    //将p3指向后半部分的头，p2指向前半部分的头进行比对
    p3=p1;
    p2=head;
    bool res=true;
    while (p1!=nullptr && p2!=nullptr)
    {
        if(p1->val!=p2->val){
            res=false;
            break;
        }
        p1=p1->next;
        p2=p2->next;

    }
    p1=p3->next;
    p3->next=nullptr;
    while (p1!=nullptr)//将后半部分逆序回来
    {
        p2=p1->next;
        p1->next=p3;
        p3=p1;
        p1=p2;
    }
    return res;
}
```

![image-20231015171830155](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231015171830155.png)

#### 四、将单向链表按某值划分为左边小、中间相等、右边大的形式（分隔链表）

**题目**：给定一个单链表的头节点head，节点的值类型是整型，再给定一个整数pivot。实现一个调整链表的函数，将链表调整为左部分都是值小于pivot的节点，中间部分都是值等于pivot的节点，右部分都是值大于pivot的节点。

<img src="%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231015102642956.png" alt="image-20231015102642956" style="zoom: 80%;" />



> 法一：利用数组partition，将链表放入数组中，将数组分割成大于、小于、等于，再将数组中的结点串起来
>
> 法二：分割链表，将链表分成三部分，分别为大于、小于、等于，将这三个链表头尾相连即可。

代码如下：

```C++
ListNode* listPartition2(ListNode* head,int pivot){
    ListNode* SH=nullptr; // 创建三条链表，有头和尾节点
    ListNode* ST=nullptr;
    ListNode* EH=nullptr;
    ListNode* ET=nullptr;
    ListNode* MH=nullptr;
    ListNode* MT=nullptr;
    ListNode* next=nullptr;
    while (head) //遍历初始链表
    {
        next=head->next; //保存下一结点
        head->next=nullptr; //将当前结点取出，判断接到那条链表上
        if(head->val<pivot){
            if(SH==nullptr){
                SH=head;
                ST=head;
            }
            else{
                ST->next=head;
                ST=head;
            }           
        }
        else if (head->val==pivot)
        {
            if(EH==nullptr){
                EH=head;
                ET=head;
            }
            else{
                ET->next=head;
                ET=head;
            }
        }
        else{
            if(MH==nullptr){
                MH=head;
                MT=head;
            }
            else{
                MT->next=head;
                MT=head;
            }
        }
        head=next;
        
    }
    // 将链表互相之间连接
    if(ST!=nullptr){
            
            ST->next=EH;
            ET=ET==nullptr?ST:ET;
    }
    if (ET!=nullptr){
            ET->next=MH;
    }
    return SH!=nullptr?SH:(EH!=nullptr?EH:MH);
        
}
```



#### 五、复制含有随机指针节点的链表

![image-20231013114516279](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231013114516279.png)

链接：[138. 随机链表的复制 - 力扣（LeetCode）](https://leetcode.cn/problems/copy-list-with-random-pointer/solutions/2361362/138-fu-zhi-dai-sui-ji-zhi-zhen-de-lian-b-6jeo/)

**法一： 哈希表**

> 利用哈希表，拷贝一个新链表，并建立映射关系，再遍历构建新链表各节点的`next`和`random`引用指向即可。
>
> ![img](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/1604747285-lmVIhC-Picture8.png)

**代码如下**

```C++
Node* copyListWithRand1(Node* head){
    if(head==nullptr){
        return head;
    }
    unordered_map<Node*,Node*> map; //建立哈希表
    Node* cur=head;
    while (cur!=nullptr) //拷贝新链表
    {
        map[cur]=new Node(cur->val);
        cur=cur->next;
    }
    cur=head;
    while(cur !=nullptr){//从头开始遍历将每个新链表与旧链表引用对应
        map[cur]->next=map[cur->next];//拷贝节点的下一个是原节点下一个的拷贝
        map[cur]->random=map[cur->random];//拷贝节点的随机指针是原节点随机指针的拷贝
        cur=cur->next;
    }
    return map[head];
}
```

**法二：拼接+拆分**

> 考虑构建 `原节点 1 -> 新节点 1 -> 原节点 2 -> 新节点 2 -> …… `的拼接链表，如此便可在访问原节点的 `random` 指向节点的同时找到新对应新节点的 `random` 指向节点。
>
> ![img](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/1604747742-aMDdkM-Picture14.png)

**代码如下：**

```C++
Node* copyListWithRand2(Node* head){
    if(head == nullptr) return nullptr;
        Node* cur = head;
        // 1. 复制各节点，并构建拼接链表
        while(cur != nullptr) {
            Node* tmp = new Node(cur->val);
            tmp->next = cur->next;
            cur->next = tmp;
            cur = tmp->next;
        }
        // 2. 构建各新节点的 random 指向
        cur = head;
        while(cur != nullptr) {
            if(cur->random != nullptr)
                cur->next->random = cur->random->next;
            cur = cur->next->next;
        }
        // 3. 拆分两链表
        cur = head->next;
        Node* pre = head, *res = head->next;
        while(cur->next != nullptr) {
            pre->next = pre->next->next;
            cur->next = cur->next->next;
            pre = pre->next;
            cur = cur->next;
        }
        pre->next = nullptr; // 单独处理原链表尾节点
        return res;      // 返回新链表头节点
}
```



#### 六、两个单链表相交的一系列问题

![image-20231013114712155](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231013114712155.png)

```C++
ListNode* getIntersectNode(ListNode* head1,ListNode*head2){
    if(head1==nullptr||head2==nullptr){
        return nullptr;
    }
    ListNode* loop1=getLoopNode(head1);
    ListNode* loop2=getLoopNode(head2);
    if (loop1==nullptr&&loop2==nullptr)
    {
        return noLoop(head1,head2);
    }
    if (loop1!=nullptr&&loop2!=nullptr)
    {
        return bothLoop(head1,loop1,head2,loop2);
    }
    return nullptr;
    
}
//判断是否有环，如果无环，返回null，如果有环，返回入环节点
ListNode* getLoopNode(ListNode* head){ 
    if(head==nullptr|| head->next==nullptr||head->next->next==nullptr){
        return nullptr; //三个节点以上才能形成环
    }
    ListNode* n1=head->next; //快慢指针
    ListNode* n2=head->next->next;
    while(n1!=n2){
        if(n2->next==nullptr||n2->next->next==nullptr){
            return nullptr;
        }
        n2=n2->next->next;
        n1=n1->next;
    }
    n2=head;
    while (n1!=n2) //n2 会到头节点重走一遍，最后n1、n2在入环结点相遇
    {
        n1=n1->next;
        n2=n2->next;
    }
    
    return n1;
}
// 两个无环链表的相交节点，如果有返回第一个相交节点，如果无则返回null
ListNode* noLoop(ListNode* head1,ListNode* head2){
    if(head1==nullptr||head2==nullptr){
        return nullptr;
    }
    ListNode* cur1=head1;
    ListNode* cur2=head2;
    int n=0;
    while (cur1->next)//找链表1的长度
    {
        n++;
        cur1=cur1->next;
    }
    while (cur2->next)//找链表2的长度
    {
        n--;
        cur2=cur2->next;
    }
    if(cur1!=cur2){//无环链表如果相交最好肯定结点相同
        return nullptr;
    }
    cur1=n>0?head1:head2; //谁长令谁为cur1
    cur2=cur1==head1?head2:head1; //谁短令谁为cur2
    n=abs(n);   
    while(n!=0){//长的先走长度差值
        n--;
        cur1=cur1->next;
    }
    while (cur1!=cur2) //两指针一起走有环总会遇到
    {
        cur1=cur1->next;
        cur2=cur2->next;
    }
    
    return cur1;
}
//一个有环链表和一个无环链表 不可能相交

// 两个有环链表的相交结点，如果有返回第一个相交节点，如果无则返回null
ListNode* bothLoop(ListNode* head1,ListNode*loop1,ListNode* head2,ListNode* loop2){
    ListNode* cur1=nullptr;
    ListNode* cur2=nullptr;
    if(loop1==loop2){ //如果两链表入环节点相同，则说明他们至少在入环前相交,则方式跟无环相同
        cur1=head1;
        cur2=head2;
        int n=0;
        while (cur1!=loop1)// 找链表1到入环节点的长度
        {
            n++;
            cur1=cur1->next;
        }
        while (cur2!=loop2)// 找链表2到入环节点的长度
        {
            n--;
            cur2=cur2->next;
        }
        cur1=n>0?head1:head2; //谁长令谁为cur1
        cur2=cur1==head1?head2:head1; //谁短令谁为cur2
        n=abs(n);   
        while(n!=0){//长的先走长度差值
            n--;
            cur1=cur1->next;
        }
        while (cur1!=cur2) //两指针一起走有环总会遇到
        {
            cur1=cur1->next;
            cur2=cur2->next;
        }
        return cur1;
    }
    else{ //两链表入环节点不同
        cur1=loop1->next;
        while (cur1!=loop1) //入环后一定能与链表2的入环节点相遇
        {
            if(cur1==loop2){
                return loop1; //返回loop1 loop2都行,
            }
            cur1=cur1->next;
        }
    }
    return nullptr;
}
```



#### 七、合并k个升序链表

[23. 合并 K 个升序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-k-sorted-lists/description/)



## 四、栈和队列

### 栈

### 1、栈的基本概念

**栈**（Stack）：是只允许在一端进行插入或删除的**线性表**。首先栈是一种**线性表**，但限定这种线性表只能在某一端进行插入和删除操作。

**栈顶**（Top）：线性表允许进行插入删除的那一端。
**栈底**（Bottom）：固定的，不允许进行插入和删除的另一端。
**空栈**：不含任何元素的空表。

![在这里插入图片描述](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210218204524571.png)

### 2、栈的顺序存储结构

采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶元素的位置。

#### 自己定义栈

```C++
#define MAXSIZE 50
struct Stack
{
    int data[MAXSIZE];
    int top;
    Stack():top(-1){} //可用构造函数初始化
};
void InitStack(Stack *S){  //可以用函数初始化
    S->top=-1;  
}
bool StackEmpty(Stack *S){ //判断栈空
    if(S->top==-1){
        return true;
    }
    else{
        return false;
    }
}
void Push(Stack *S,int e){ //进栈
    if(S->top==MAXSIZE-1){
        return;
    }
    S->top++;
    S->data[S->top]=e;
    return;
}
void Pop(Stack *S,int *e){ //出栈
    if(S->top==-1){
        return;
    }
    *e =S->data[S->top];
    S->top--;
    return;
}
int GetTop(Stack *S,int *e){ //栈顶
    if(S->top == -1){   //栈空
        return 0;
    }
    *e = S->data[S->top];   //记录栈顶元素
    return *e;
}
```

#### STL库中的栈

> **#include<stack\>** 头文件
>
> **s.top()** //返回栈顶元素
> **s.push()** // 在栈顶压入一个元素
> **s.pop()** // 弹出栈顶元素
> **s.size()** //返回栈中元素的个数
> **s.empty()** //判断栈是否为空栈



### 3、栈的链式存储结构

**采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。通常采用单链表实现，并规定所有操作都是在单链表的表头进行的。这里规定链栈没有头节点，Lhead指向栈顶元素**，如下图所示。

![在这里插入图片描述](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/2021021910502017.png)

**对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是top=NULL的时候。**



链栈的结构代码：

```C++
/*栈的链式存储结构*/
/*构造节点*/
typedef struct StackNode{
    ElemType data;
    struct StackNode *next;
}StackNode, *LinkStackPrt;
/*构造链栈*/
typedef struct LinkStack{
    LinkStackPrt top;
    int count;
}LinkStack;

/*插入元素e为新的栈顶元素*/
Status Push(LinkStack *S, ElemType e){
    LinkStackPrt p = (LinkStackPrt)malloc(sizeof(StackNode));
    p->data = e;
    p->next = S->top;    //把当前的栈顶元素赋值给新节点的直接后继
    S->top = p; //将新的结点S赋值给栈顶指针
    S->count++;
    return OK;
}

/*若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR*/
Status Pop(LinkStack *S, ElemType *e){
    LinkStackPtr p;
    if(StackEmpty(*S)){
        return ERROR;
    }
    *e = S->top->data;
    p = S->top; //将栈顶结点赋值给p
    S->top = S->top->next;  //使得栈顶指针下移一位，指向后一结点
    free(p);    //释放结点p
    S->count--;
    return OK;
}

```

### 4、栈的应用

#### 一、递归

**1、递归的定义**
**递归是一种重要的程序设计方法。简单地说,若在一个函数、过程或数据结构的定义中又应用了它自身,则这个函数、过程或数据结构称为是递归定义的,简称递归**。
它通常把一个大型的复杂问题层层转化为一个与原问题相似的规模较小的问题来求解,递归策略只需少量的代码就可以描述岀解题过程所需要的多次重复计算,大大减少了程序的代码量但在通常情况下,它的效率并不是太高。

#### 二、四则运算表达式



### 队列

#### 1.队列的基本概念

**队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。**
队列是一种先进先出（First In First Out）的线性表，简称FIFO。==允许插入==的一端称为==队尾==，==允许删除==的一端称为队头。

![在这里插入图片描述](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210219144731888.png)

#### 2.队列的顺序存储结构

队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头指针 front指向队头元素，队尾指针 rear 指向队尾元素的下一个位置。

##### 1、顺序队列

队列的顺序存储类型可描述为:

```C++
#define MAXSIZE 50	//定义队列中元素的最大个数
typedef struct{
	ElemType data[MAXSIZE];	//存放队列元素
	int front,rear;
}SqQueue;
```

初始状态（队空条件）：`Q->front == Q->rear == 0`。
进队操作：队不满时，先送值到队尾元素，再将队尾指针加1。
出队操作：队不空时，先取队头元素值，再将队头指针加1。

![在这里插入图片描述](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210219152051156.png)

如图d，队列出现“上溢出”，然而却又不是真正的溢出，所以是一种“假溢出”。



#### 3.STL库中的队列

> #include<queue\>  头文件
>
> empty() 检测队列是否为空，是返回true，否则返回false
>
> size() 返回队列中有效元素的个数
>
> front() 返回队头元素的引用
>
> back() 返回队尾元素的引用
>
> push() 在队尾将元素val入队列
>
> pop() 将队头元素出队列



### 优先队列

#### 一、定义

> 优先队列：顾名思义，首先它是一个队列，但是它强调了“优先”二字，所以，已经不能算是一般意义上的队列了，它的“优先”意指取队首元素时，有一定的选择性，==即根据元素的属性选择某一项值最优的出队==
>
> 优先级队列是一个拥有权值观念的queue。它允许在底端添加元素、在顶端去除元素、删除元素。 缺省情况下，优先级队列利用一个大顶堆完成。

#### 二、二叉堆

![image-20231202134355543](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231202134355543.png)

我们设树的根结点为0，给定一个下标i，可以很容易计算得到它的父节点、左孩子、右孩子的下标。
$$
(从0出发)i的\begin{cases}
父结点&\frac {i-1}2\\
左孩子&2\times i+1\\
右孩子&2\times i+2
\end{cases}
$$

##### 二叉堆的操作



#### 堆的拓展

##### 1、双端优先级队列



##### 2、对顶堆



#### 堆的应用

##### K个最小元素和

![image-20231120105752723](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231120105752723.png)

> **法一：插入排序**
>
> 利用排序，每次将最大的元素去掉，再插入下一个元素
>
> **法二：堆**
>
> 利用最大堆，每次将最大的元素去掉，再插入下一个元素
>
> 

### 栈和队列的题

#### 1.用栈实现队列

[232. 用栈实现队列 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-queue-using-stacks/solutions/656774/tu-jie-guan-fang-tui-jian-ti-jie-yong-zh-4hru/)

> 队列是一种先入先出（FIFO）的数据结构，而栈是一种后入先出（LIFO）的数据结构，所以一个栈绝对满足不了队列的 FIFO 的特性。
>
> 比如 1 2 3，队列 1 2 3 进，应该 1 2 3 出，但是 1 2 3 进了栈，出来以后会成 3 2 1，和 1 2 3 是相反的，所以再需要一个栈，把 3 2 1 返成 1 2 3。
>
> 因此这里需要两个栈，分别是**输入栈和输出栈：**
>
> **输入栈来反转元素的入队顺序，元素入只能从输入栈进（push）。**
>
> **输出栈用来存储元素的正常顺序，元素出只能从输出栈出（pop、peek）。**



**图解**

<img src="%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/1642039117-gbDJZG-20220102_172137631_0.jpg" alt="bf0649d5850c6b0c488bb41481731da" style="zoom:90%;" /><img src="%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/1642039117-XajbyA-20220102_172210106_0.jpg" alt="ec707d02f08a529375faac008c73d12" style="zoom:90%;" />



<img src="%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/1642039117-gwoxWy-20220102_172240157_0.jpg" alt="78c2da16f1bd9221e94bb4f23d46201" style="zoom:90%;" />

**代码如下**

```C++
class MyQueue {
private:
    stack<int> inStack,outStack;//定义输入栈和输出栈
    void in2out(){//将输入栈中的元素转到输出栈中
        while(!inStack.empty()){
            outStack.push(inStack.top());
            inStack.pop();
        }
    }
public:
    MyQueue() {
        
    }
    
    void push(int x) {
        inStack.push(x);
    }
    
    int pop() {
        if(outStack.empty()){
            in2out();
        }
        int x=outStack.top();
        outStack.pop();
        return x;
    }
    
    int peek() {
        if(outStack.empty()){
            in2out();
        }
        int x=outStack.top();
        return x;
    }
    
    bool empty() {
        return outStack.empty()&&inStack.empty();
    }
};
```

#### 2.用队列实现栈

[225. 用队列实现栈 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-stack-using-queues/solutions/432204/yong-dui-lie-shi-xian-zhan-by-leetcode-solution/)

**法一：用两个队列**

> ![fig1](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/225_fig1.gif)

**法二：一个队列**

> ![fig2](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/225_fig2.gif)

## 五、二叉树

### 一、定义

普通定义：二叉树是每个节点**最多只有两个子树**的数结构，两个子树称为左子树和右子树。
递归定义：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树又同样都是二叉树。

### 二、性质

> 1. **任意二叉树第i层最大结点数为$2^{i-1}。(i\ge 1)$**
>
>    归纳法证明。
>
> 2. **深度为k的二叉树最大结点总数为$$2^k-1。(k\ge 1)$$**
>
>    证明：$\sum^k_{i=1}2^{i-1}=2^k-1$
>
> 3. **对于任意二叉树，用$n_0,n_1,n_2$分别表示叶子结点，度为1的结点，度为2的结点的个数，则有关系式$n_0=n_2+1$**
>
>    证明：总结点个数$n=n_0+n_1+n_2$；总结点中除根结点外，其余各结点都有一个分支进入，设m为分支总数，则有$n=m+1$，又因为这些分支都是由度为1或2的结点射出的，所以有$m=n_1+2n_2$，于是有$n=n_1+2n_2+1$;最后将关于n的两个关系式化简得证。
>
> 4. **n个结点==完全二叉树==深度为$\lfloor log_2n\rfloor +1$**
>
>    证明：设深度k，则有$2^{k-1}\le n<2^k\Rightarrow k-1\le log_2n<k\Rightarrow=\lfloor log_2n\rfloor +1 $
>
> 5. **性质5其实描述的是完全二叉树中父子结点间的逻辑对应关系。** 假如对一棵==完全二叉树==的所有顶点按层序遍历的顺序从1开始编号,对于编号后的结点$i$ ：
>
>    (1)i=1时表示i是根结点；
>
>    (2)i>1时：①i的根结点为$\frac{i}2$。②若$2 i > n $，结点i 无左孩子，且为叶子结点。③若$2 i + 1 > n$ ，结点i无右孩子，可能为叶子结点。
>    当然如果完全二叉树的顶点从0开始编号，那么上述关系就要相应修改一下。
>
>    

### 三、二叉树的形态

**五种基本形态**

从上面二叉树的递归定义可以看出，二叉树或为空，或为一个根结点加上两棵左右子树，因为两棵左右子树也是二叉树也可以为空，所以二叉树有5种基本形态：
![在这里插入图片描述](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20200330145137194.png)

**三种特殊形态**
![在这里插入图片描述](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20200330145319114.png)

**满二叉树**：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是$(2^k) -1 $，则它就是满二叉树。
**完全二叉树**：完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。==要注意的是满二叉树是一种特殊的完全二叉树==

**完美二叉树**：所有叶节点在同一层



### 二叉树的存储结构

#### 1.顺序存储

> 顺序结构存储就是使用==数组==来存储，一般使用数组==只适合表示完全二叉树==，因为不是完全二叉树会有空间的浪费。而现实中使用中只有堆才会使用数组来存储。二叉树顺序存储在物理上是一个数组，在逻辑上是一颗二叉树。
>
> ![在这里插入图片描述](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5NjM4Nw==,size_16,color_FFFFFF,t_70.png)

#### 2.链式存储

> 二叉树的链式存储结构是指，==用链表来表示一棵二叉树==，即用链来指示元素的逻辑关系。 通常的方法是链表中每个结点由三个域组成，数据域和左右指针域，左右指针分别用来给出该结点左孩子和右孩子所在的链结点的存储地址 。链式结构又分为二叉链和三叉链，当前我们学习中一般都是二叉链，后面课程学到高阶数据结构如红黑树等会用到三叉链。
>
> ![在这里插入图片描述](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5NjM4Nw==,size_16,color_FFFFFF,t_70-16988967379045.png)



### 二叉树的建立与操作

==类似于链表==

```C++
struct TreeNode
{
    int val;
    TreeNode* right;
    TreeNode* left;
    TreeNode():val(0),right(nullptr),left(nullptr){}
    TreeNode(int x):val(x),right(nullptr),left(nullptr){}
    TreeNode(int x,TreeNode*left,TreeNode*right):val(x),left(left),right(right){}
};
```



### 二叉树的遍历

#### 深度优先遍历，递归序

> 深度优先遍历有三种方案，前序，中序，后序
>
> <font size=5>**深度优先遍历每个结点都能到自己3次**</font>
>
> ![image-20231026100526601](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231026100526601.png)
>
> <font size=5>**可以由递归序得先序中序后序**</font>
>
> **先序是递归序中第一次出现的结点**
>
> **中序是递归序中第二次出现的结点**
>
> **后序是递归序中第三次出现的结点**
>
> ![image-20231026100740356](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231026100740356.png)



#### 1. 先序遍历(根左右)

> 先序遍历可以想象为，一个小人从一棵二叉树根节点为起点，沿着二叉树外沿，逆时针走一圈回到根节点，路上遇到的元素顺序，就是先序遍历的结果
>
> ![在这里插入图片描述](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/202012091634524.gif)

==先序遍历结果为：A B D H I E J C F K G==



#### 2.中序遍历（左根右）

> 中序遍历可以看成，二叉树每个节点，垂直方向投影下来（可以理解为每个节点从最左边开始垂直掉到地上），然后从左往右数，得出的结果便是中序遍历的结果
>
> ![在这里插入图片描述](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20201209164211397.gif)

==中序遍历结果为：H D I B E J A F K C G==

#### 3.后序遍历（左右根）

> 后序遍历就像是==剪葡萄，我们要把一串葡萄剪成一颗一颗的。==
>
> ![在这里插入图片描述](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/2020120916532175.gif)

==后序遍历结果：H I D J E B K F G C A==





**代码如下：**

使用递归

```C++
//使用递归的先序、中序、后序
void PreOrderRecur(TreeNode* head){
    if(head==nullptr){
        return;
    }
    cout<<head->val<<" ";
    PreOrderRecur(head->left);
    PreOrderRecur(head->right);
}
void InOrderRecur(TreeNode* head){
    if(head==nullptr){
        return;
    }
    InOrderRecur(head->left);
    cout<<head->val<<" ";
    InOrderRecur(head->right);
}
void PosOrderRecur(TreeNode* head){
    if(head==nullptr){
        return;
    }
    PosOrderRecur(head->left);
    PosOrderRecur(head->right);
    cout<<head->val<<" ";
}
```



不使用递归，自己压栈

```C++
//使用非递归,自己压栈
void PreOrderUnRecur(TreeNode* head){
    if(head==nullptr){
        return;
    }
    stack<TreeNode*> stk;
    stk.push(head);
    while (!stk.empty())
    {
        head=stk.top();
        stk.pop();
        cout<<head->val<<" ";

        if(head->right!=nullptr){ //先压右孩子，后出
            stk.push(head->right);
        }
        if(head->left!=nullptr){ //后压左孩子，先出
            stk.push(head->left);
        }
        

    }
}
void InOrderUnRecur(TreeNode* head){
    if(head==nullptr){
        return;
    }
    stack<TreeNode*> stk;
    
    while (!stk.empty()||head!=nullptr)
    {
        if(head!=nullptr){ //一直找左孩子，直到为空
            stk.push(head);
            head=head->left;  
        }
        else{  //找右孩子
            head=stk.top();
            stk.pop();
            cout<<head->val<<" ";
            head=head->right;
        }

    }
    
}
void PosOrderUnRecur(TreeNode* head){
    if(head==nullptr){
        return;
    }
    // 两个栈，
    stack<TreeNode*> stk1;
    stack<TreeNode*> stk2;
    stk1.push(head);
    while (!stk1.empty())
    {
        head=stk1.top();
        stk1.pop();
        stk2.push(head);
        if(head->left!=nullptr){
            stk1.push(head->left);
        }
        if(head->right!=nullptr){
            stk1.push(head->right);
        }
    }
    while (!stk2.empty()){
            cout<<stk2.top()->val<<" ";
            stk2.pop();
    }
}
```



#### 4.层次遍历（宽度优先遍历）：使用队列

> 层次遍历（宽度优先遍历）很好理解，就是从根节点开始，一层一层，从上到下，每层从左到右，依次写值就可以了，层次遍历用队列
>
> ![在这里插入图片描述](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaW5lc2Vrb2Jl,size_16,color_FFFFFF,t_70-16980278373319.png)



**代码如下：**

```C++
// 宽度优先遍历，使用队列
void widthTraversal(TreeNode* head){
    if(head==nullptr){
        return;
    }
    queue<TreeNode*> q;
    q.push(head);
    while (!q.empty())
    {
        TreeNode* cur=q.front(); //一层一层弹出
        q.pop();
        cout<<cur->val<<" ";
        if(cur->left!=nullptr){ //先进左结点，先出
            q.push(cur->left);
        }
        if(cur->right!=nullptr){//先进右结点，后出
            q.push(cur->right);
        }
    }
    
}
```



##### 求一颗二叉树的宽度（宽度优先遍历）

```C++
int treeWidth(TreeNode* head){
    if(head==nullptr){
        return 0;
    }
    queue<TreeNode*> q;
    q.push(head);
    unordered_map<TreeNode*,int> levelMap;
    levelMap.insert(pair<TreeNode*,int>(head,1));
    int curLevel=1;
    int curLevelNodes=0;
    int Max=-1;
    while (!q.empty())
    {
        TreeNode* cur=q.front(); //一层一层弹出
        q.pop();
        int curNodeLevel=levelMap[cur]; //获取当前节点的层数
        if(curNodeLevel==curLevel){   //如果当前节点的层数是该层，则结点数加1
            curLevelNodes++;
        }else{   //否则，更新结点数的最大值，并层数+1，当前节点个数为1.
            Max=max(Max,curLevelNodes);
            curLevel++;
            curLevelNodes=1;
        }
        if(cur->left!=nullptr){ //先进左结点，先出
            levelMap.emplace(cur->left,curNodeLevel+1); //记录孩子的层数
            q.push(cur->left);
        }
        if(cur->right!=nullptr){//先进右结点，后出
            levelMap.emplace(cur->right,curNodeLevel+1); //记录孩子的层数
            q.push(cur->right);
        }
        Max=max(Max,curLevelNodes);//最后一层再比较一次
    }
    return Max;
}
```



#### 二叉树遍历的应用

##### 1.奇偶数Ⅰ

![image-20231109102325366](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231109102325366.png)

> **法一：层序遍历——利用队列**
>
> 从上至下依层遍历所有结点，同时记录结点所在层数
>
> **（1）结点队列：记录结点**
>
> **（2）层数队列：记录结点所在层**
>
> 然后对出队结点判断其元素值及层数的奇偶性是否一致
>
> **法二：前序遍历**
>
> 把层数作为参数传递

**代码如下：**

```C++
bool isParityTree(TreeNode* head){
    queue<TreeNode*>node_queue; //结点队列
    queue<int>level_queue; //结点所在层数队列
    node_queue.push(head);
    level_queue.push(1);
    while(!node_queue.empty()){
        TreeNode* node_ptr=node_queue.front();
        node_queue.pop();
        int level=level_queue.front();
        level_queue.pop();
        if(node_ptr!=nullptr){
            if(node_ptr->val%2!=level%2){// 判断奇偶性是否相同
                return false;
            }
            node_queue.push(node_ptr->left); //压入左孩子
            level_queue.push(level+1);      //记录左孩子的层数
            node_queue.push(node_ptr->right);//压入右孩子
            level_queue.push(level+1); //记录右孩子的层数
        }
    }
    return true;
}
```

##### 2.奇偶树Ⅱ

![image-20231109112831305](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231109112831305.png)



**代码如下：**

```C++
//利用层序遍历
bool isParityTree1(TreeNode* head){
    queue<TreeNode*>node_queue; //结点队列
    queue<int>level_queue; //结点所在层数队列
    node_queue.push(head);
    level_queue.push(1);
    TreeNode* pre_node=nullptr; //记录前一个出队的非空结点
    int pre_level=0;//记录前一个出队的非空结点层数，初始值为0
    while(!node_queue.empty()){
        TreeNode* node_ptr=node_queue.front();
        node_queue.pop();
        int level=level_queue.front();
        level_queue.pop();
        if(node_ptr!=nullptr){
            if(node_ptr->val%2!=level%2){// 判断奇偶性是否相同
                return false;
            }
            else if(pre_level==level&&pre_node->val>=node_ptr->val){//判断是否递增
                return false;
            }
            pre_level=level;
            pre_node=node_ptr;
            node_queue.push(node_ptr->left); //压入左孩子
            level_queue.push(level+1);      //记录左孩子的层数
            node_queue.push(node_ptr->right);//压入右孩子
            level_queue.push(level+1); //记录右孩子的层数
        }
    }
    return true;
}
//利用前序遍历
vector<TreeNode*> pre_nodes(20);
bool isParityTree2(TreeNode* head,int level){
    if(head==nullptr){
        return true;
    }
    if(head->val%2!=level%2){
        return false;
    }
    if(pre_nodes[level]!=nullptr&&pre_nodes[level]->val>=head->val){
        return false;
    }
    pre_nodes[level]=head;//记录一层最先遇到的结点
    
    return isParityTree2(head->left,level+1)&&isParityTree2(head->right,level+1);

}
```



### 二叉树的判断

#### 1.判断是否是搜索二叉树——中序遍历or树型dp

> **二叉搜索树**又称二叉排序树，它或者是一棵空树，或者是具有以下性质的二叉树:
> 1.若它的左子树不为空，则左子树上所有节点的值都小于根节点的值
> 2.若它的右子树不为空，则右子树上所有节点的值都大于根节点的值
> 3.它的左右子树也分别为二叉搜索树
>
> 即==左<根<右==
>
> <font color='red'>搜索二叉树是不允许数据冗余的，意思就是插入相同的值只会存在一个该值</font>
>
> <img src="%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/3c84287ce09c442480be91ba6c589f58.png" alt="在这里插入图片描述" style="zoom:80%;" />



**代码如下**


利用中序遍历

```C++
//利用中序遍历(递归)进行搜索二叉树的判断
int preValue=-1;
bool checkBST(TreeNode* head){
    if(head==nullptr){
        return true;
    }
    bool isLeftBst= checkBST(head->left);//判断左子树是不是搜索二叉树 
    //在中序遍历中，这个地方是打印行为，这里就变成处理比较行为
    if(!isLeftBst){
        return false;
    }
    if(head->val<=preValue){ //如果值降序，说明不是搜索二叉树
        return false;
    }
    else{
        preValue=head->val; //记录当前结点的值
    }
    return checkBST(head->right); //判断右子树是不是搜索二叉树
}
//利用中序遍历(非递归)进行搜索二叉树的判断
bool checkBST2(TreeNode* head){
    if(head==nullptr){
        return true;
    }
    stack<TreeNode*> stk;
    int  preValue=-1;
    while (!stk.empty()||head!=nullptr)
    {
        if(head!=nullptr){ //一直找左孩子，直到为空
            stk.push(head);
            head=head->left;  
        }
        else{  //为空后，弹出结点，打印，然后找右孩子
            head=stk.top();
            stk.pop();
            if(head->val<=preValue){//在中序遍历中，这个地方是打印行为，这里就变成处理比较行为
                return false;
            }
            else{
                preValue=head->val;
            }
            head=head->right;
        }

    }
    return true;
}

```

利用树型dp

```C++
//利用树型dp（动态规划）判断搜索二叉树
class ReturnData{ //定义一个返回数据类，返回三个数据，对左子树需要最大值，对右子树需要最小值，取全集
    public:
        bool isBST;
        int Min;
        int Max;
        ReturnData(bool is,int mi, int ma){
            isBST= is;
            Min= mi;
            Max=ma;
        }
};
ReturnData* process1(TreeNode* x){
    if(x==nullptr){
        return nullptr;//必须这么返回，因为你不管怎么设最大最小都有干扰
    }
    ReturnData* leftData=process1(x->left); //得到左子树的数据
    ReturnData* rightData=process1(x->right); //得到右子树的数据
    //找x的最小，最大
    int Min=x->val;
    int Max=x->val;
    if(leftData!=nullptr){
        Min=min(Min,leftData->Min);
        Max=max(Max,leftData->Max);
    }
    if(rightData!=nullptr){
        Min=min(Min,rightData->Min);
        Max=max(Max,rightData->Max);
    }
    //判断是否是搜索二叉树
    bool isBST=true;
    if(leftData!=nullptr&&(!leftData->isBST||leftData->Max>=x->val)){
        isBST=false;
    }
    if(rightData!=nullptr&&(!rightData->isBST||rightData->Min<=x->val)){
        isBST=false;
    }
    return new ReturnData(isBST,Min,Max);
}
bool checkBST3(TreeNode* head){
    return process1(head)->isBST;
}
```



#### 2.判断是否是完全二叉树——宽度优先遍历

> 利用宽度优先遍历，根据以下两个条件判断是否是完全二叉树
>
> ![image-20231103175658472](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231103175658472.png)

**代码如下：**

```C++
//用宽度优先遍历判断是否是完全二叉树
bool checkCBT(TreeNode* head){
     if(head==nullptr){
        return true;
    }
    queue<TreeNode*> q;
    bool leaf=false;
    q.push(head);
    while (!q.empty())
    {
        TreeNode* cur=q.front(); //一层一层弹出
        q.pop();
        //两个条件，1.对任一结点，有右无左 false，2.在1不成立条件下，如果遇到第一个左右子结点不全，后续都是叶节点
        if((cur->left==nullptr&&cur->right!=nullptr)||(leaf&&(cur->left!=nullptr||cur->right!=nullptr))){
            return false;
        }
        if(cur->left!=nullptr){ //先进左结点，先出
            q.push(cur->left);
        }
        if(cur->right!=nullptr){//先进右结点，后出
            q.push(cur->right);
        }
        if(cur->left==nullptr||cur->right==nullptr){ //判断是否是叶结点
            leaf=true;
        }
        
    }
    return true;
}
```

#### 3.判断是否是满二叉树

> 判断是否是满二叉树只需要满足一个条件：
>
> 深度为k的二叉树结点总数为$$2^k-1。(k\ge 1)$$
>
> 故可以遍历找深度和结点数
>
> 也可用树型dp

**代码如下：**

```C++
//判断是否是满二叉树,用性质结点数=2^深度-1
class Info{  //返回数据类型，返回两数据
    public:
        int height; //深度
        int nodes; //结点数
        Info(int h,int n){
            height=h;
            nodes=n;
        }
};
Info process3(TreeNode *x){
    if(x==nullptr){
        return Info(0,0);
    }
    Info leftData=process3(x->left); 
    Info rightData=process3(x->right);
    int height=max(leftData.height,rightData.height)+1; //计算当前节点的高度
    int nodes=leftData.nodes+rightData.nodes+1; //计算当前节点的所有结点数
    return Info(height,nodes);
}
bool checkFull(TreeNode* head){
    if(head==nullptr){
        return true;
    }
    // return pow(2,process3(head).height)-1==process3(head).nodes?true:false;
    return process3(head).nodes==((1<<process3(head).height)-1)?true:false; //用位运算计算次方
}
```



#### 4.判断是否是平衡二叉树——利用树型dp求解

> 判断「平衡二叉树」的 2 个条件：
>
> - **1. 是「二叉排序树」(二叉搜索树)**
>
> - **2. 任何一个节点的左子树或者右子树都是「平衡二叉树」（左右高度差小于等于 1）**
>
>   ![image-20231106105641638](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231106105641638.png)



**代码如下：**

```c++
//利用树型dp判断是否是平衡二叉树
class ReturnType{ //设置两个返回数据
    public:
        bool isBalanced;
        int height;
        ReturnType(bool isB,int hei){
            isBalanced=isB;
            height=hei;
        }
};
ReturnType process(TreeNode* x){
    if(x==nullptr){ 
        return ReturnType(true,0);
    }

    ReturnType leftData=process(x->left); //通过递归得到左树的数据
    ReturnType rightData=process(x->right);//得到右数的数据

    int height=max(leftData.height,rightData.height)+1; //获取高度信息
    //获取是否是平衡二叉树的信息
    bool isBalanced=leftData.isBalanced&&rightData.isBalanced&&abs(leftData.height-rightData.height)<2;
    
    return  ReturnType(isBalanced,height);//返回两信息，x是否是平衡树
    
}
bool checkBalanced(TreeNode* head){
    return process(head).isBalanced;
}
```



### 四、最优二叉树（哈夫曼树）

![image-20231113113435150](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231113113435150.png)

![image-20231113113546663](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231113113546663.png)

#### 最优二叉树的性质

**1.最优二叉树是满二叉树**

**2.最优二叉树中，如果两个叶结点的权重值不同，则权重值小的叶结点在
树中的层数大于等于权重值大的叶结点**

**3.若有n个结点，则在哈夫曼树的构造过程中，新建了n-1个结点，最终所得到的==结点总数为2n-1==**

**4.给定一组叶结点权重，存在最优二叉树，==权重最小和次小==的叶结点在树
的最下层并且互为兄弟结点**

**5.由于哈夫曼树只有度为0和2的结点，不存在度为1的结点，即n=n0+n2，且又由二叉树的性质，叶子结点数等于度为2的结点数加1（==n0=n2+1==），故从而可以求得哈夫曼树的叶子结点数和度为2的结点数。**





### 二叉树的一些题

#### 1.给定两个二叉树的节点node1和node2，找到他们的最低公共祖先节点

> **通过两种情况来分析**
>
> ![image-20231107105817990](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231107105817990.png)



**代码如下：**

```c++
//最优解，分为两种情况，一种o1或o2是公共父结点，一种都不是要找相交
TreeNode* lowestCommonAncestor2(TreeNode* head,TreeNode* o1,TreeNode* o2){
    if(head==nullptr||head==o1||head==o2){// 当遇到空或o1或o2返回
        return head;
    }
    TreeNode* left=lowestCommonAncestor2(head->left,o1,o2); //从左子树获取信息，为空，o1,o2
    TreeNode* right=lowestCommonAncestor2(head->right,o1,o2);//从右子树获取信息，为空，o1,o2
    if(left!=nullptr&&right!=nullptr){ //当左或右都不为空，说明是第二种情况，那么此时的结点就是公共结点
        return head;
    }
    return left!=nullptr?left:right;//当左或右有一个不为空，返回不空的，都为空，返回空。
}
```



#### 2.在二叉树中找到一个节点的后继节点

![image-20231107111708733](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231107111708733.png)

> 后继节点就是中序遍历序列中的下一个节点
>
> 





#### 3.表达式树



#### 4.二叉树的序列化和反序列化

**1.前序遍历方法**

> - 序列化的时候被分成三部分（左 -> 右）：根节点、左子树、右子树
> - 因此反序列化用队列
> - **（一般来说，还原二叉树需要前序+中序/后序+中序，由于node包含所有节点的信息，包括空指针的信息，因此可以直接还原）**

**代码如下：**

```java
public String serialize(TreeNode root) {
    StringBuilder sb = new StringBuilder();
    serialize(root, sb);
    return sb.toString();
}

public void serialize(TreeNode root, StringBuilder sb) {
    if (root == null) {
        sb.append("null,");
        return;
    }

    // 前序遍历位置
    sb.append("" + root.val + ",");

    serialize(root.left, sb);
    serialize(root.right, sb);        
}

public TreeNode deserialize(String data) {

    LinkedList<String> nodes = new LinkedList<>();

    for (String node : data.split(",")) {
        nodes.offer(node);
    }

    return deserialize(nodes);
}

public TreeNode deserialize(LinkedList<String> nodes) {
    if (nodes.isEmpty()) {
        return null;
    }

    // 前序遍历位置
    String node = nodes.poll();
    if ("null".equals(node)) {
        return null;
    }
    TreeNode root = new TreeNode(Integer.parseInt(node));

    root.left = deserialize(nodes);
    root.right = deserialize(nodes);

    return root;
}

```

**2.后序遍历方法**

> - 后序遍历的序列化时候，只需把append放到后序遍历的位置去，因此序列化的顺序也改变了
> - 被分成三部分（左 -> 右）：左子树、右子树、根节点
> - 因此反序列化用栈
> - 反序列化的时候，我们还是要先获取根节点，**然后是右子树**、最后才是左子树

**代码如下：**

```java
public String serialize(TreeNode root) {
    StringBuilder sb = new StringBuilder();
    serialize(root, sb);
    return sb.toString();
}

public void serialize(TreeNode root, StringBuilder sb) {
    if (root == null) {
        sb.append("null,");
        return;
    }

    serialize(root.left, sb);
    serialize(root.right, sb);        

    // 后序遍历位置
    sb.append("" + root.val + ",");
}

public TreeNode deserialize(String data) {

    LinkedList<String> nodes = new LinkedList<>();

    for (String node : data.split(",")) {
        nodes.push(node);
    }

    return deserialize(nodes);
}

public TreeNode deserialize(LinkedList<String> nodes) {
    if (nodes.isEmpty()) {
        return null;
    }

    // 后序遍历位置
    String node = nodes.pop();
    if ("null".equals(node)) {
        return null;
    }
    TreeNode root = new TreeNode(Integer.parseInt(node));

    root.right = deserialize(nodes);
    root.left = deserialize(nodes);

    return root;
}

```

**3.中序遍历方法**

> - 我们不能通过中序遍历将字符串反序列化成一颗二叉树，前序遍历根节点在第一个，后序遍历根节点在最后一个，二中序遍历根节点在中间
> - 但是可以进行序列化



```java
public void serialize(TreeNode root, StringBuilder sb) {
    if (root == null) {
        sb.append("null,");
        return;
    }

    serialize(root.left, sb);
    // 中序遍历位置
    sb.append("" + root.val + ",");
    serialize(root.right, sb);        
}
```

**4.层序遍历方法：**

> - 序列化同样按照层序遍历，利用队列遍历每一层节点，然后序列化到字符串中去
> - 反序列化的时候同样也是用队列进行层序遍历的，因为空指针也被记录进去，所以要用`i`记录子节点的位置，不管子节点是不是空的，都要先获取判断一下

**代码如下：**



```java
public String serialize(TreeNode root) {
    if (root == null) {
        return "";
    }

    StringBuilder sb = new StringBuilder();
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.offer(root);

    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();

        if (node == null) {
            sb.append("null,");
            continue;
        }

        sb.append("" + node.val + ",");

        queue.offer(node.left);
        queue.offer(node.right);
    }

    return sb.toString();
}

public TreeNode deserialize(String data) {
    if ("".equals(data) || data.length() == 0) {
        return null;
    }

    String[] nodes = data.split(",");
    TreeNode root = new TreeNode(Integer.parseInt(nodes[0]));

    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.offer(root);

    for (int i = 1; i < nodes.length;) {
        // 先出队，获取节点
        TreeNode node =  queue.poll();

        // 左子树
        String left = nodes[i++];
        if ("null".equals(left)) {
            node.left = null;
        } else {
            node.left = new TreeNode(Integer.parseInt(left));
            queue.offer(node.left);
        }

        // 右子树
        String right = nodes[i++];
        if ("null".equals(right)) {
            node.right = null;
        } else {
            node.right = new TreeNode(Integer.parseInt(right));
            queue.offer(node.right);
        }
    }

    return root;
}

```





#### 5.折纸问题

![image-20231114152109686](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231114152109686.png)



### 二叉树拓展

#### 1.树的存储方式

与二叉树相似，树也有**顺序存储**与 **链接存储**两种方式，而选择何种方式与在树结
点中记录哪些表示树逻辑结构的信息相关
常用的树逻辑结构表示法：**父亲表示法** 、 **孩子表示法**以及**孩子兄弟表示法**

##### 父亲表示法





#### 前缀树

==实现生成前缀树，包括添加、删除、查找的功能，此外还需要查找某个前缀出现的次数==

![image-20231123085132007](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231123085132007.png)

> 前缀树用于统计词频，如下图当我们添加==“abc”，“bck”,“abd”,“ace”==时就会得到如下树。其中根节点不存储字符，只起标记位置作用，为了存储26个字母，每个节点有26条隐含的路可分别存储a-z的字符，添加上节点时，路才显示为存储的字符，那么可以看出这种树和一般的树不同，最多每个节点有26个子节点；
>
> 如果像存储“abc”,“abd”这样，不同字符串的相同位置“ab”相同时，使用同一个节点。
> ![image-20231123085151737](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231123085151737.png)



> 为了增加前缀树的功能，我们在节点上增加了两个变量pass和end初始化为0。pass是这个节点经过了几次，end是以这个节点结束有几次。
>
> ![image-20231123085539972](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231123085539972.png)



**代码如下：**

```C++
#define num 26
class TrieNode{
    public:
        int pass; //经过的次数
        int end; //结尾的次数
        TrieNode* nexts[num]; //设置字符串个数的最多前缀‘a~z’
        //如果字符特别多，用数组浪费空间：
        //也可以用哈希表unordered_map<char,TrieNode> nexts; char记录路，TrieNode表示路的下一个节点
        //TreeMap<> nexts;
        TrieNode():pass(0),end(0){
            //memset 函数用于设置nexts数组的初始值为0
            memset(nexts,0,sizeof(nexts)); 
        }

};

class TrieTree{
    private:
        TrieNode *root;
    public:
        TrieTree();
        ~TrieTree();
        void destroy(TrieNode *node);
        void insert(string word);
        int search(string word);
        void delete_word(string word);
        int prefixNumber(string pre);

};
// 构造函数
TrieTree::TrieTree(){
    root=new TrieNode();
}
//析构函数
TrieTree::~TrieTree(){
    destroy(root);
}
//删除整棵树
void TrieTree::destroy(TrieNode *root)
{
	if(root ==NULL)
		return;
	for(int i = 0; i < num; i++)
	{	//每个new出的数组需要删除
		destroy(root->nexts[i]);
	}
	delete root;
	root = NULL;
}
//插入函数
void TrieTree::insert(string word)
{
	if(&word==NULL)	//不能用word.empty()来写，不然不能加入“”的字符串							
		return;
	if(word.empty()){
		root->pass++;
	}
	TrieNode *node = root;
	int index = 0;
	for(int i = 0;i < word.size(); i++)
	{
		index = word[i] - 'a';					//将输入的字符转换为索引值a是0，b是1...
		if(node->nexts[index] == NULL)			//这条路未被创建
		{
			node->nexts[index] = new TrieNode();//创建路
		}
		node = node->nexts[index];				//指向新建的路
		node->pass++;							//经过+1
	}
	node->end++;								//最后再记录结束
	
}
//查找函数
int TrieTree::search(string word)
{
	if(&word==NULL) //不能用word.empty()来写，不然不能加入“”的字符串
		return 0;
	int index = 0;
	TrieNode *node = root;
	for(int i = 0;i < word.size();i++) //遍历这个字符串
	{
		index = word[i] - 'a';
		if(node->nexts[index]==NULL) //如果没有这条路则换回0
			return 0;
		node = node->nexts[index];
	}
	return node->end;
}


//删除函数
void TrieTree::delete_word(string word)
{
	if(search(word) == 0)		//先进行查找确定存在
		return;
	TrieNode *node = root;
	TrieNode *tmp = root;
	int index = 0;
	for(int i = 0;i < word.size();i++)
	{
		index = word[i] - 'a';
		tmp = node->nexts[index];			//使用中间变量记录当前节点的下一个节点
		if(--node->nexts[index]->pass == 0){	//如果将--pass后，节点的pass为0，表示以后的节点都不存在
			destroy(tmp);
			node->nexts[index]=NULL;
			break;		//释放
        }   
		else{
            node = tmp;							//当前节点移动到下一个节点
        }
    }
	node->end--;
}

int TrieTree::prefixNumber(string pre) 
{
	if(pre==""){
		return root->pass;
	}
	if(&pre==NULL) //不能用pre.empty()来写，不然不能加入“”的字符串
		return 0;
	
	TrieNode* node = root;
	
	int index = 0;
	for(int i = 0;i < pre.size();i++)
	{
		index = pre[i] - 'a';
		if(node->nexts[index] == NULL)	//不存在此前缀直接返回0个
			return 0;
		node = node->nexts[index];		
	}	return node->pass;
}
```



## 六、图

<font size=4>**【知识框架】**</font>

![在这里插入图片描述](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYWxfRm9vbF8=,size_16,color_FFFFFF,t_70.png)

### 图的基本概念

在**线性表**中，数据元素之间是被串起来的，仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继。

在**树形结构**中，数据元素之间有着明显的层次关系，并且每一层上的数据元素可能和下一层中多个元素相关，但只能和上一层中一个元素相关。

图是一种较线性表和树更加复杂的数据结构。在**图形结构**中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。

### 一、图的定义

**图（Graph）是由顶点的有穷非空集合$V(G)$和顶点之间边的集合$E(G)$组成，**通常表示为:$G=(V,E)$，其中G表示个图，V是图G中顶点的集合，E是图G中边的集合。**若$V=\{v_1,v_2,\cdots ,v_n\}$则用$|V|$表示图中G中顶点的个数，也称图G的阶，$E=\{(u,v)|u\in U,v\in V\}$,用$|E|$表示图中G中边的条数。**

> 注意:线性表可以是空表，树可以是空树，==但图不可以是空图。==就是说，图中不能一个顶点也没有，图的顶点集V一定非空，但边集E可以为空，此时图中只有顶点而没有边。



### 二、图的基本概念和术语

#### 1、有向图

若E是有向边(也称弧)的有限集合时，则图G为有向图。弧是顶点的有序对，记为<v, w>，其中v,w是顶点，v称为弧尾，w称为弧头，<v,w>称为从顶点v到顶点w的弧，也称v邻接到w，或w邻接自v。

![在这里插入图片描述](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210227111745661.png)

#### 2、无向图



### 三、图的存储结构

#### 一、邻接矩阵

#### 二、邻接表

#### 三、十字链表

#### 四、邻接多重表

#### 五、边集数组





```java
public class Node{
	public int value;
	public int in;
	public int out;
	public ArrayList<Node> nexts;
	public ArrayList<Edge> edges;
	public Node(int value){
		this.value=value;
		in=0;
		out=0;
		nexts=new ArrayList<>();
		edges=new ArrayList<>();
	}
}
public class Edge{
    public int weight;
    public Node from;
    public Node to;
    public Edge(int weight,Node from,Node to){
        this.weight=weight;
        this.from=from;
        this.to=to;
    }
}
public class Graph{
    public HashMap<Integer,Node> nodes;
    public HashSet<Edge> edges;
   	public Graph(){
        nodes=new HashMap<>();
        edges=new HashSet<>();
    }
}
public static Graph createGraph()
```



```C++
class Edge;
//节点的五个数据，值，入度，出度，下一节点，该节点出发的边
class Node{
    public:
        int value;
        int in;
        int out;
        list<Node*> nexts;
        list<Edge*> edges;
        Node(int value){
            this->value=value;
            in=0;
            out=0;
        }
};
// Graph类有点和边两大部分，使用hash_map存储节点,使用hash_set存储边的信息
class Graph{
    public: 
        unordered_map<int,Node*> nodes;
        unordered_set<Edge*> edges;
        Graph(){};
        Graph(Node* node,Edge* edge){
            nodes.emplace(1,node);
            edges.emplace(edge);
            
        }

};

// 边上的权重、当前边的from和to节点
class Edge{
    public:
        int weight;
        Node* from;
        Node* to;
        Edge(int weight,Node* from,Node* to){
            this->weight=weight;
            this->from=from;
            this->to=to;
        }
};
Graph createGraph(vector<vector<int>> matrix){
    Graph graph;
    for(int i=0;i<matrix.size();i++){
        int weight=matrix[i][0];
        int from = matrix[i][1];
		int to = matrix[i][2];
		//Graph的node里不含有from节点、to节点时建上 
		if(graph.nodes.find(from) == graph.nodes.end())
			graph.nodes[from] = new Node(from);
		if(graph.nodes.find(to) == graph.nodes.end())
			graph.nodes[to] = new Node(to);
		//拿出from，to点
		Node* fromNode = graph.nodes[from];		
		Node* toNode = graph.nodes[to];
		//Node* fromNode = graph.nodes.find(from)->second;		
		//Node* toNode = graph.nodes.find(to)->second;
		//新建边 
		Edge* newEdge = new Edge(weight, fromNode, toNode);
		
		//增加节点的四个数据 
		fromNode->nexts.push_back(toNode);
		fromNode->edges.push_back(newEdge);
		fromNode->out++;
		toNode->in++;
		graph.edges.insert(newEdge);
    }
    return graph;
}
```



### 四、图的遍历

#### 1.宽度优先遍历

**图的广度优先遍历类似于树的层序遍历。**

> ==广度优先遍历是一种分层的查找过程==，每向前走一步可能访问一批顶点，不像深度优先遍历那样有往回退的情况，因此它不是一个递归的算法。为了实现逐层的访问，==算法必须借助一个辅助队列==，以记忆正在访问的顶点的下一层顶点。
>
> **步骤如下：**
>
> ①利用队列实现 ；
> ②从源节点开始依次按照宽度进队列，然后弹出 ；
> ③每弹出一个点，把该节点所有没有进过队列的邻接点放入队列；
> ④直到队列变空；



**代码如下：**

```c++
//宽度优先遍历
void bfs(Node* nodes){
    if(nodes==NULL){
        return;
    }
    queue<Node*> q; //用队列来遍历
    unordered_set<Node*> set;//用集合辅助队列，防止重复
    q.push(nodes);
    set.emplace(nodes);
    while (!q.empty()) 
    {
        Node* help=q.front(); //弹出队列
        q.pop();
        cout<<help->value<<" ";
        for(Node* t:help->nexts){ //遍历当前节点的邻接节点
            if(set.find(t)==set.end()){ //如果不在哈希表，则入队并记录
                q.push(t);
                set.emplace(t);
            }
        }
    }
    
}
```

**BFS算法性能分析**

> 无论是邻接表还是邻接矩阵的存储方式，BFS 算法都需要借助一个辅助队列Q, n个顶点均需入队一次，在最坏的情况下，==空间复杂度为$O(V)$==。
>
> 采用==邻接表存储==方式时，每个顶点均需搜索一次(或入队一次)， 在搜索任一顶点的邻接点时，每条边至少访问一次，算法总的==时间复杂度为$O(V+E)$==。
>
> 采用==邻接矩阵存储==方式时，查找每个顶点的邻接点所需的时间为$O(V)$,故算法总的==时间复杂度$O(V^2)$==



#### 2.深度优先遍历

**深度优先搜索类似于树的先序遍历。**

> 如其名称中所暗含的意思一样，这种搜索算法所遵循的搜索策略是==尽可能“深”地搜索一个图==。它的基本思想如下:首先访问图中某一起始顶点v，然后由v出发，访问与v邻接且未被访问的任一顶点$w_1$，再访问与$w_1$邻接且未被访问的任一顶点…重复上述过程。==当不能再继续向下访问时，依次退回到最近被访问的顶点==，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，直至图中所有顶点均被访问过为止。
>
> **步骤如下：**
>
> ①利用栈实现 ；
> ②从源节点开始把节点按照深度放入栈，然后弹出 ；
> ③每弹出一个点，若该节点有没有进过栈的邻接点存在，把该节点和没有进过栈的**一个**邻接点放入栈 ；
> ④直到栈变空；

**代码如下：**

```C++
//深度优先遍历 利用栈（可以用递归）
void dfs(Node* node)
{
	if(node == NULL)	return;
	stack<Node*> s;
	unordered_set<Node*> set;
	s.push(node); 
	set.insert(node);
	cout<<node->value<<" "; 				//第一个元素直接输出 
	while(!s.empty())
	{
		Node* help = s.top();
		s.pop();
		for(auto tmp : help->nexts)
		{
			if(set.find(tmp) == set.end())	//该节点如果没有遍历过
			{
				s.push(help);				//把当前节点压回栈
				s.push(tmp);				//把第一个找到的邻接节点压入栈，并记录
				set.insert(tmp);
				cout<<tmp->value<< " ";
				break;						//一次只找一个 
			}
		} 
	}
} 
```



**DFS算法性能分析**

> DFS算法是一个递归算法，需要借助一个递归工作栈，故其空间复杂度为$O(V)$
>
> 对于n个顶点e条边的图来说，邻接矩阵由于是二维数组，要查找每个顶点的邻接点需要访问矩阵中的所有元素，因此都需要$O(V^2)$时间。而邻接表做存储结构时，找邻接点所需的时间取决于顶点和边的数量，所以是$O(V+E)$，显然对于点多边少的稀疏图来说，邻接表结构使得算法在时间效率上大大提高。
>
> 对于有向图而言，由于它只是对通道存在可行或不可行，算法上没有变化，是完全可以通用的

### 五、拓扑排序







## 七、贪心算法

### 一、概念

**贪心算法（Greedy Alogorithm）又叫登山算法**，它的根本思想是逐步到达山顶，即逐步获得最优解，是解决最优化问题时的一种简单但是==适用范围有限==的策略。

贪心算法没有固定的框架，算法设计的关键是贪婪策略的选择。贪心策略要无后向性，也就是说某状态以后的过程不会影响以前的状态，至于当前状态有关。

贪心算法是==对某些求解最优解问题的最简单、最迅速的技术==。某些问题的最优解可以通过一系列的最优的选择即贪心选择来达到。但局部最优并不总能获得整体最优解，但通常能获得近似最优解。

在每一步贪心选择中，只考虑当前对自己最有利的选择，而不去考虑在后面看来这种选择是否合理。



### 问题

#### 1.会议安排

 一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。给你每一个项目开始的时间和结束的时间（给你一个数组，里面是一个个具体的项目），你来安排宣讲的日程，要求会议室进行的宣讲场次最多，返回这个最多的宣讲场次。

> #### 题目分析：
>
> 我们按照每个项目的结束时间来进行贪心，哪个项目的结束时间早，我们就选哪个项目。定义一个以结束时间升序的优先级队列，每次从队顶中拿出一个活动，用该活动的开始时间和上一个选择了的活动的结束时间进行比较，如果满足条件，就说明能够安排这个活动。

**代码如下：**

```C++
class Program{
    public:
        int start;
        int end;
        Program(int start,int end){
            this->end=end;
            this->start=start;
        }
};
bool compare(Program* o1,Program* o2){
    return o1->end<o2->end;
}
int bestArrange(vector<Program*> programs,int timePoint){
    sort(programs.begin(),programs.end(),compare);
    int result=0;
    //从左往右依次遍历所有的会议
    for(int i=0;i<programs.size();i++){
        if(timePoint<=programs[i]->start){
            result++;
            timePoint=programs[i]->end;
        }

    }
    return result;
}
```

#### 2.字符串拼接

给定一些字符串，让你通过一定的算法来将这些字符串拼接起来，使拼接后的字符串字典序最小。
我们假设给定的字符串是：abfgh和kgegr，我们有2种拼接方式，第一种：abfghkgegr；第二种：kgegrabfgh。这两种拼接方式我们选择第一种，因为第一种所拼接出来的字符串的字典序小。

> ### 题目分析：
>
> 我们可以设定一种贪心策略：将所有的字符串按从小到大排序，然后拼接起来。但是这种贪心策略是不对的，我们举个例子：假设有2个字符串：b，ba。我们按从小到大排序然后拼接得到的字符串是bba，但是这个字符串不是最小的，还有更小的就是bab，所以这种贪心策略是不对的。
>
> 假设另一种贪心策略：给定两个字符串a，b，如果a+b得到的字符串小于b+a得到的字符串，那么就把a排在前面，b排在后面
>
> 否则，b放在前面，a放在后面。



**代码如下：**

```C++
bool compare(string a, string b){
    return a+b<b+a;
}
string lowestString(vector<string> strs){
    if(&strs==NULL||strs.size()==0){
        return "";
    }
    sort(strs.begin(),strs.end(),compare);
    string res="";
    for(int i=0;i<strs.size();i++){
        
        res+=strs[i];
    }
    return res;
}
```

#### 3.金条切分

一块金条切成两半，是需要花费和长度数值相同的铜板的，比如长度为20的金条，不管切成长度为多大的两半，都需要花费20个铜板，一群人想整分整块金条，怎么分最省铜板？

例如：给定数组【10,20,30】，代表一共三个人，整块金条的长度为10+20+30=60，金条要分成10,20,30三个部分。如果，先把长度为60的金条分成10和50，花费60，在办长度为50的金条分成20和30，花费50，一共花费110铜板。
但是如果先把长度为60的金条分成30和30的，在把长度为30的金条分成10和20，一共花费90铜板。
输入一个数组，输出分割最小代价。

> ### 思路：
>
> 利用哈夫曼编码，每次选取数组中最小和次小的两个元素进行合并，然后把合并后的数字重新放入数组中去，然后重复进行上述过程，直到数组中只有一个数字时停止。（和找最优二叉树的算法一模一样------哈夫曼算法）
>
> 上述过程完成后可以生成一个二叉树，我们以【10,20,30】举例：
> 

## 八、查找

<img src="%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231128093802534.png" alt="image-20231128093802534" style="zoom:50%;" />

### 一、查找的基本概念

**查找(Searching)**：就是根据给定的某个值，在**查找表**中确定一个其**关键字**等于给定值的数据元素( 或记录)。

**查找表(Search Table)**：是由同一类型的数据元素(或记录)构成的集合。

**关键字(Key)**：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。例如，在由一个学生元素构成的数据集合中，学生元素中“学号”这一数据项的值唯一地标识一名学生。

**静态查找表(Static Search Table)**：只作查找操作的查找表。

- 主要操作

1. 查询某个“特定的”数据元素是否在查找表中。
2. 检索某个“特定的”数据元素和各种属性。

**动态查找表(Dynamic Search Table)**： 在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。

- 主要操作

1. 查找时插入不存在的数据元素。
2. 查找时删除已存在的数据元素。

==**平均查找长度**==：在查找过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度，则是所有查找过程中进行关键字的比较次数的平均值，其数学定义为
$$
ASL=\sum^n_{i=1}P_iC_i
$$
这个式子中，n是查找表的长度；$P_i$是查找第$i$个数据元素的概率，一般认为每个数据元素的查找概率相等，即$P_i=\frac{1}n$;$C_i$是找到第$i$个数据元素所需进行的比较次数。平均查找长度是衡量查找算法效率的最主要的指标。

### 二、顺序表查找

#### 1.定义

**顺序查找(Sequential Search) 又叫线性查找**，是最基本的查找技术，作为一种最直观的查找方法，其基本思想是从线性表的一端开始，逐个检查关键字是否满足给定的条件。若查找到某个元素的关键字满足给定条件，则查找成功，返回该元素在线性表中的位置；若已经查找到表的另一端，但还没有查找到符合给定条件的元素，则返回查找失败的信息。

#### 2.算法

**代码如下：**

```C++
/*有哨兵顺序查找*/
int Sequential_Search(int *a, int n, int key){
	int i;
	a[0] = key;	//设置a[0]为关键字，称之为“哨兵”
	i = n;	//循环从数组尾部开始
	while(a[i] != key){
		i--;
	}
	return i;	//返回0则说明查找失败
}
```

**算法分析：**

> 这种在查找方向的尽头放置“哨兵”免去了在查找过程中每一次比较后都要判断查找位置是否越界的小技巧，看似与原先差别不大，但在总数据较多时，效率提高很大，是非常好的编码技巧。
> 上述顺序表查找时间复杂度是$O(n)$



### 三、顺序查找的应用

#### 1.查找最大值和最小值

查找顺序表中的最大值和最小值，比较次数不超过$\frac32 n$

> 算法1：朴素查找法——比较次数：2(n-1)
>
> ```C++
> int res[2];
> int* findmaxandmin(int arr[],int n){
>  int max=arr[0];
>  int min=arr[0];
>  for(int i=1;i<n;i++){
>      if(max<arr[i]) max=arr[i];
>      if(min>arr[i]) min=arr[i];
>  }
> 
>  res[0]=max;
>  res[1]=min;
>  return res;
> }
> ```
>
> 算法2：快速查找法——比较次数$\frac32 n$
>
> 先比较两者，再用较小值和较大值分别与最小值和最大值比较
>
> ```C++
> int res2[2];
> int* findmaxandmin2(int arr[],int n){
>     int max=arr[0];
>     int min=arr[0];
>     int k=n%2;//n是奇数，k从1开始，否则从0开始
>     while (k<n)
>     {
>         if(arr[k]<arr[k+1]){
>             if(min>arr[k]) min=arr[k];
>             if(max<arr[k+1]) max=arr[k+1];
>         }
>         else{
>             if(min>arr[k+1]) min=arr[k+1];
>             if(max<arr[k]) max=arr[k];
>         }
>         k=k+2; //每次同时比较两个元素
>     }
>     res2[0]=max;
>     res2[1]=min;
>     return res2;
> }
> ```
>
> 

#### 2.查找区间内所有质数

查找正整数区间[1,n]（n>1）内所有质数。

##### (1).试除法 ——时间复杂度$O(n\sqrt n)$

**代码如下：**

```c++
#include <iostream>
#include <cmath>
using namespace std;

// 判断一个数是否是质数的函数
bool isPrime(int num) {
  // 1和负数都不是质数
  if (num <= 1) return false;
  // 2是唯一的偶数质数
  if (num == 2) return true;
  // 其他偶数都不是质数
  if (num % 2 == 0) return false;
  // 从3开始，每次加2，只检查奇数因子
  for (int i = 3; i <= sqrt(num); i += 2) {
    // 如果有任何因子可以整除，就不是质数
    if (num % i == 0) return false;
  }
  // 没有找到任何因子，就是质数
  return true;
}

int main() {
  // 输入n的值
  int n;
  cout << "请输入n的值：";
  cin >> n;
  // 遍历区间[1,n]，输出所有质数
  cout << "区间[1," << n << "]内的所有质数如下：" << endl;
  for (int i = 1; i <= n; i++) {
    if (isPrime(i)) {
      cout << i << " ";
    }
  }
  cout << endl;
  return 0;
}

```

##### (2)埃氏筛选法——时间复杂度:O(nloglog(n))

**代码如下：**

```C++
#include <iostream>
#include <vector>
using namespace std;

// 用埃式筛选法查找正整数区间[1,n]内所有质数的函数
vector<int> eratosthenes(int n) {
  vector<int> primes; // 存储找到的素数
  vector<bool> is_prime(n + 1, true); // 标记每个数是否是素数，初始都为true
  is_prime[0] = is_prime[1] = false; // 0和1不是素数，标记为false
  for (int i = 2; i <= n; i++) {
    if (is_prime[i]) { // 如果i是素数，就把它加入到primes中
      primes.push_back(i);
      // 用i的倍数从i*i开始筛掉所有能被i整除的数，因为小于i*i的合数已经被更小的素数筛掉了
      for (int j = i * i; j <= n; j += i) {
        is_prime[j] = false;
      }
    }
  }
  return primes; // 返回素数的向量
}

int main() {
  // 输入n的值
  int n;
  cout << "请输入n的值：";
  cin >> n;
  // 调用eratosthenes函数，得到区间[1,n]内的所有素数
  vector<int> primes = eratosthenes(n);
  // 输出素数
  cout << "区间[1," << n << "]内的所有素数如下：" << endl;
  for (int p : primes) {
    cout << p << " ";
  }
  cout << endl;
  return 0;
}

```



##### (3)合数限定法——时间复杂度：O(n)

**代码如下：**

```


```



##### (4)欧拉筛选法——时间复杂度:O(n)

**代码如下：**

```C++
#include <iostream>
#include <vector>
using namespace std;

// 用欧拉筛选法查找正整数区间[1,n]内所有质数的函数
vector<int> euler(int n) {
  vector<int> primes; // 存储找到的素数
  vector<bool> is_prime(n + 1, true); // 标记每个数是否是素数，初始都为true
  is_prime[0] = is_prime[1] = false; // 0和1不是素数，标记为false
  for (int i = 2; i <= n; i++) { // i从2循环到n（外层循环）
    if (is_prime[i]) primes.push_back(i); // 如果i没有被前面的数筛掉，则i是素数，加入到primes中
    for (int j = 0; j < primes.size() && i * primes[j] <= n; j++) { // 筛掉i的素数倍，即i的primes[j]倍
      // j循环枚举现在已经筛出的素数（内层循环）
      is_prime[i * primes[j]] = false; // 倍数标记为合数，也就是i用primes[j]把i * primes[j]筛掉了
      if (i % primes[j] == 0) break; // 最神奇的一句话，如果i整除primes[j]，退出循环
      // 这样可以保证线性的时间复杂度
    }
  }
  return primes; // 返回素数的向量
}

int main() {
  // 输入n的值
  int n;
  cout << "请输入n的值：";
  cin >> n;
  // 调用euler函数，得到区间[1,n]内的所有素数
  vector<int> primes = euler(n);
  // 输出素数
  cout << "区间[1," << n << "]内的所有素数如下：" << endl;
  for (int p : primes) {
    cout << p << " ";
  }
  cout << endl;
  return 0;
}
```



### 四、有序表查找

#### 1.折半查找

**折半查找(Binary Search)技术，又称为二分查找。**它的前提是线性表中的记录==必须是关键码有序(通常从小到大有序)==，线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。

**代码如下：**

```C++
//实现方法1
int BinarySearch1(int arr[],int left,int right,int key){
    int low=left;
    int high=right;
    int mid;
    while(low<=high){
        mid = (low + high)/2;	//取中间位置
		if(arr[mid] == key){
			return mid;	//查找成功返回所在位置
		}else if(arr[mid] > key){
			high = mid - 1;	//从前半部分继续查找
		}else{
			low = mid + 1;	//从后半部分继续查找
		}
	}
	return -1;	//查找失败，返回-1
}
//实现方法2
int BinarySearch2(int arr[],int left,int right,int key){
    int low=left-1;
    int high=right+1;
    int mid;
    while(high>low+1){
        mid = (low + high)/2;	//取中间位置
		if(arr[mid] == key){
			return mid;	//查找成功返回所在位置
		}else if(arr[mid] > key){
			high = mid ;	//从前半部分继续查找
		}else{
			low = mid ;	//从后半部分继续查找
		}
	}
	return -1;	//查找失败，返回-1    
}
```



#### 2.二分查找的应用

##### 1.区间查询

<img src="%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231128155657543.png" alt="image-20231128155657543" style="zoom:50%;" />

**代码如下：**

```C++
int SearchinInterval(int arr[],int left,int right,int key){
    int low=left-1;
    int high=right+1;
    int mid;
    while(high>low+1){
        mid = (low + high)/2;	//取中间位置
		if(arr[mid] >= key){
			high = mid ;	
		}else{
			low = mid ;	//从后半部分继续查找
		}
	}
	return high;//或者 low;	// high :>=key的最小值位置 low:<key的最大值位置   
}
```



##### 2.快速求幂

给定正整数a和n，求$a^n$的值

> 法一：直接迭代：$a^n=a^n-1*a$  ——时间复杂度O(n)
>
> 法二：二分递归：$a^n=a^{\frac n2}*a^{\frac n2}*a^{n\%2}$——时间复杂度O(log(n))

**代码如下：**

```C++
int Power(int x,int n){
    if(n==1){
        return x;
    }
    int pow=Power(x,n/2);
    pow=pow*pow;
    if(n%2==1){
        pow=pow*x;
    }
    return pow;
}
```



##### 3.快速查找

查找未排序序列$<a_1,a_2.\dots,a_n>$中的第k小元素

> 法一: 循环k次选择排序或冒泡排序 ——时间复杂度O(kn)
>
> 法二：快速或递归排序——时间复杂度：O(nlogn)[排序]+O(1)[找第k小元素]
>
> 法三： 快速建最小堆+k次出堆——时间复杂度：O(n)+O(klogn)
>
> 法四：利用快速排序的partition过程，进行二分——时间复杂度：O(n)



**法四，代码如下：（注意k输入时要-1）**

```C++
void swap(int* a,int* b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
int Partition(int* a,int begin,int end)
{
    
    int L = begin,R = end,key = begin;//定义L,R,key下标
    while(L < R)
    {
        while(a[R] >= a[key] && L < R)//右边先走，右边大于等于key就一直走下去，否则停下来，加上判断L < R，防止越界
        {
            R--;
        }
        while(a[L] <= a[key] && L < R)//同理
        {
            L++; 
        }
        swap(&a[L],&a[R]);//都停下来后交换
    }
    swap(&a[key],&a[R]);//最后key值和相遇点交换
    return R;
}

int QuickSearch(int arr[],int left,int right, int k){
    if(left<right){
        int m=Partition(arr,left,right);
        if(m==k) return arr[m];
        if(m<k) {
            return QuickSearch(arr,m+1,right,k);
        }

        else{
            return QuickSearch(arr,left,m-1,k);
        }
    }
    return arr[left];
}
```

### 五、线性索引查找

索引按照结构可以分为**线性索引、树形索引和多级索引**。
这里主要介绍线性索引，所谓线性索引就是将索引项集合组织为线性结构，也称为**索引表**。我们重点介绍三种线性索引：**稠密索引、分块索引和倒排索引**。

### 六、动态查找

#### 一、二叉排序树（二叉查找树）

**二叉排序树(也称二叉查找树)**或者是一棵空树，或者是具有下列特性的二叉树:

1. 若左子树非空，则左子树上所有结点的值均小于根结点的值。
2. 若右子树非空，则右子树上所有结点的值均大于根结点的值。
3. 左、右子树也分别是一棵二叉排序树。

根据二叉排序树的定义，==左子树结点值<根结点值<右子树结点值==，所以对二叉排序树进行中序遍历，可以得到一个==递增的有序序列==。例如，下图所示二叉排序树的中序遍历序列为123468。

![在这里插入图片描述](%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210309095505317.png)

#### 二、平衡二叉树(AVL树)

**平衡二叉树(Self-Balancing Binary Search Tree 或 Height-Balanced Binary Search Tree)是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1**。
它是一种高度平衡的二叉排序树。它要么是一棵空树， 要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。我们将**二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF (Balance Factor)** ， 那么平衡二叉树上所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。





### 散列表查找（哈希表）

#### 一、散列表查找的基本概念

**散列表**是根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。我们只需要通过某个函数f，使得
$$
存储位置=f(关键字)
$$
==那样我们可以通过查找关键字不需要比较就可获得需要的记录的存储位置。==

**散列技术**既是一种存储方法， 也是一种查找方法，散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置$f(key)$

这里我们把这种对应关系f称为**散列函数**，又称为**哈希(Hash) 函数**。按这个思想，采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为**散列表**或**哈希表(Hash table)**。那么关键字对应的记录存储位置我们称为**散列地址**。

==散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为**冲突**==，这些发生碰撞的不同关键字称为**同义词**。一方面，设计得好的散列函数应尽量减少这样的冲突；另一方面，由于这样的冲突总是不可避免的，所以还要设计好处理冲突的方法





#### 二、散列函数的构造方法

在构造散列函数时，必须注意以下几点：

1. 散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。
2. 散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间中，从而减少冲突的发生。
3. 散列函数应尽量简单，能够在较短的时间内计算出任一关键字对应的散列地址。

下面介绍常用的散列函数。

##### 1、直接定址法

直接取关键字的某个线性函数值为散列地址，散列函数为
$$
H(key)=key或H(key)=a*key+b
$$
这种方法计算最简单，且不会产生冲突。它适合关键字的分布基本连续的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。

有反函数，容易反解得到key

举例：0~100岁的人口数字统计表，可以吧年龄数值直接当做散列地址。

##### 2、数字分析法



##### 3、平方取中法

取关键字平方后的中间几位作为散列地址，即散列函数为：
$$
H(key)=key^2的中间几位
$$
其中，所取位数由散列表大小确定



##### 4、折叠法



##### 5、除留余数法

